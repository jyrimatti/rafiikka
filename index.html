<!DOCTYPE HTML>
<html>

<head>
    <meta charset="UTF-8">
    <style>
        #chartdiv {
            width: 100%;
            height: 500px;
        }
        h1 {
            font-weight: 100;
            font-style: italic;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            margin-left: 1em;
            margin-bottom: 0;
        }
    </style>

    <!-- TODO
        - auttaako päällekäisten tooltippien näkymiseen jos luo joka seriesille uuden tooltip-instanssin?
        - junanumero labeliksi viivan myötäisesti
        - dateaxis custom formaatit
        - dateaxis custom gridlines
        - dateaxis päivälabel erikseen tuntitickien alle
        - yaxis custom gridlines
        - yaxis tuki aikataulupaikkaväleille
        - infinite scroll, eli kun scrollataan reunaan tai hypätään tyhjälle, niin siirretään xAxis min/max keskikohta vanhaan reunaan. Ja trigataan load ennakkotietodatalle
        - jump-to-date laatikko
        - aikataulupiste (erityisesti vaakasuora viiva) kertomaan "raide" eli siis kapasiteetinhallintayksikkö
		- sijainti heijastumaan urliin
        - ratatyöt
        - valitut objektit listaksi legendiin, tooltip mukaan
        - selectioniin valinnan alue tooltipiksi tms
        - ratanumero-akseli nyt olettaa ratakm=1000m. Miten korjata?
        - columnille Label-lapsi, jossa EI123
        - kielivalinta fi/en
    -->

    <script src="https://www.amcharts.com/lib/version/4.9.19/core.js"></script>
	<script src="https://www.amcharts.com/lib/version/4.9.19/charts.js"></script>
	<script src="https://www.amcharts.com/lib/version/4.9.19/lang/fi_FI.js"></script>
    <script src="https://www.amcharts.com/lib/version/4.9.19/themes/animated.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <script src="datefns.js"></script>
    <script>
        let log = (msg1, msg2, msg3, msg4, msg5, msg6) => {
            if (console && console.log) {
                console.log(dateFns.dateFns.format(new Date(), 'yyyy-MM-dd HH:mm:ss.SSS'), ":", msg1, msg2, msg3, msg4, msg5, msg6);
            }
        };

        window.infraAPIUrl = 'https://rata.digitraffic.fi/infra-api/0.6/';
        window.etj2APIUrl = 'https://rata.digitraffic.fi/jeti-api/0.6/';
		window.aikatauluAPIUrl = 'https://rata.digitraffic.fi/api/v1/trains/';

		let params = new URLSearchParams(window.location.hash.replace("#", "?"));
		
        let sijaintiParam = params.get("sijainti") || "009";
		let aikaParam     = new Date(params.get("aika") || new Date().toISOString());
		let kestoParam    = dateFns.durationFns.parse(params.get("kesto") || "P1D");

        log("Parametri Sijainti", sijaintiParam);
		log("Parametri Aika", aikaParam);
		log("Parametri Kesto", kestoParam);

        window.ikkuna = [dateFns.dateFns.sub(aikaParam, kestoParam), dateFns.dateFns.add(aikaParam, kestoParam)];
		window.rajat  = [dateFns.dateFns.addDays(ikkuna[0], -3), dateFns.dateFns.addDays(ikkuna[1], 3)];

        let pyoristaAjanhetki = x => dateFns.dateFns.format(x, "yyy-MM-dd'T00:00:00Z'");

		let infraAikavali = '&time=' + pyoristaAjanhetki(aikaParam) + "/" + pyoristaAjanhetki(aikaParam);
		let etj2Aikavali = '&time=' + rajat.map(function(x) { return pyoristaAjanhetki(x); }).join("/");
        let rumaAikavali = '&start=' + pyoristaAjanhetki(rajat[0]) + "&end=" + pyoristaAjanhetki(rajat[1]);

        let ratanumerotUrl            = infraAPIUrl + "radat.json?propertyName=ratakilometrit,ratanumero" + infraAikavali;
        let rautatieliikennepaikatUrl = infraAPIUrl + "rautatieliikennepaikat.json?propertyName=lyhenne,muutRatakmsijainnit,nimi,ratakmvalit,tunniste,tyyppi,uicKoodi,virallinenRatakmsijainti" + infraAikavali;
        let liikennepaikanOsatUrl     = infraAPIUrl + "liikennepaikanosat.json?propertyName=liikennepaikka,lyhenne,muutRatakmsijainnit,nimi,tunniste,uicKoodi,virallinenRatakmsijainti" + infraAikavali;
        let raideosuudetUrl           = infraAPIUrl + "aikataulupaikat.json?cql_filter=tyyppi=%27raideosuus%27&propertyName=tunniste.tunniste,tunniste.ratakmvalit,tunniste.turvalaiteNimi,tyyppi,uickoodi" + infraAikavali;
        let laituritUrl               = infraAPIUrl + "aikataulupaikat.json?cql_filter=tyyppi=%27laituri%27&propertyName=tunniste.tunniste,tunniste.kuvaus,tunniste.laskennallisetRatakmvalit,tunniste.tunnus,tyyppi,uickoodi" + infraAikavali;
        let eiUrl = etj2APIUrl + 'ennakkoilmoitukset.json?cql_filter=tila=%27hyväksytty%27&propertyName=ajankohdat,liikennevaikutusalue.laskennallisetRatakmvalit,sisainenTunniste,tunniste,voimassa' + etj2Aikavali;
        let esUrl = etj2APIUrl + 'ennakkosuunnitelmat.json?cql_filter=tila=%27hyväksytty%27&propertyName=sisainenTunniste,tyonosat.ajankohdat,tyonosat.tekopaikka.laskennallisetRatakmvalit,tunniste,voimassa' + etj2Aikavali;
        let vsUrl = etj2APIUrl + 'vuosisuunnitelmat.json?cql_filter=tila%3C%3E%27poistettu%27&propertyName=ajankohdat,sisainenTunniste,tunniste,kohde.laskennallisetRatakmvalit,voimassa' + etj2Aikavali;
        let loUrl = etj2APIUrl + 'loilmoitukset.json?cql_filter=tila=%27aktiivinen%27&propertyName=ensimmainenAktiivisuusaika,ratakmvalit,sisainenTunniste,tunniste,viimeinenAktiivisuusaika' + etj2Aikavali;
        let junasijainnitUrl = 'https://rata.digitraffic.fi/api/v1/train-locations/latest/';
        let ratakmMuunnosUrl = 'https://rata-beta.digitraffic.fi/infra-api/0.6/koordinaatit/{coord}.json?propertyName=ratakmsijainnit&srsName=crs:84';
        let rtUrl = 'https://rata.digitraffic.fi/api/v1/trackwork-notifications.json?state=ACTIVE' + rumaAikavali;
        let lrUrl = 'https://rata.digitraffic.fi/api/v1/trafficrestriction-notifications.json?state=SENT' + rumaAikavali;

        let errorHandler = ev => log("Virhe!", ev);

        let loggingDelegate = f => (a, b, c) => {
            try {
                return f(a, b, c);
            } catch (e) {
                errorHandler(e);
                throw e;
            }
        };

        let on = (obj, event, f) => obj.on(event, loggingDelegate(f));

        let add = (obj, name, f) => obj.add(name, loggingDelegate(f));



        let ajankohtaAikavaleiksi = ajankohta => {
            if (ajankohta.yhtajaksoinen) {
                let ret = ajankohta.yhtajaksoinen.split("/").map(x => new Date(x));
                return ret[0] < rajat[1] && rajat[0] < ret[1]
                      ? [ret.map(function(x) { return x < rajat[0] ? rajat[0] : x > rajat[1] ? rajat[1] : x })]
                      : [];
            } else {
                let ensimmainenAloitusPaiva = new Date(ajankohta.toistuva.ensimmainenAloitusPaiva); // "2019-10-29"
                let viimeinenAloitusPaiva   = new Date(ajankohta.toistuva.viimeinenAloitusPaiva);   // "2020-05-29"
                let aloitusViikot           = ajankohta.toistuva.aloitusViikot;                     // viikottain|jokatoinen|jokaneljäs
                let aloitusViikonpaivat     = ajankohta.toistuva.aloitusViikonpaivat;               // [ma|ti|ke|to|pe|la|su]
                let timezone                = ajankohta.toistuva.timezone;                          // "Europe/Helsinki"
                let aloitusaika             = ajankohta.toistuva.aloitusaika;                       // "06:00:00"
                let kesto                   = dateFns.durationFns.parse(ajankohta.toistuva.kesto);  // "PT43200S";
                
                let kelpaaViikonPerusteella = paiva => {
                    if (aloitusViikot == 'viikottain') {
                        return true;
                    } else if (aloitusViikot == 'jokatoinen') {
                        return (dateFns.dateFns.differenceInCalendarISOWeeks(paiva, ensimmainenAloitusPaiva)) % 2 == 0;
                    } else if (aloitusViikot == 'jokaneljas') {
                        return (dateFns.dateFns.differenceInCalendarISOWeeks(paiva, ensimmainenAloitusPaiva)) % 4 == 0;
                    } else {
                        throw 'Virheellinen aloitusViikot: ' + aloitusViikot;
                    }
                };

                let ma = aloitusViikonpaivat.includes('ma');
                let ti = aloitusViikonpaivat.includes('ti');
                let ke = aloitusViikonpaivat.includes('ke');
                let to = aloitusViikonpaivat.includes('to');
                let pe = aloitusViikonpaivat.includes('pe');
                let la = aloitusViikonpaivat.includes('la');
                let su = aloitusViikonpaivat.includes('su');
                let kelpaaViikonpaivanPerusteella = paiva => {
                    return ma && dateFns.dateFns.isMonday(paiva) ||
                           ti && dateFns.dateFns.isTuesday(paiva) ||
                           ke && dateFns.dateFns.isWednesday(paiva) ||
                           to && dateFns.dateFns.isThursday(paiva) ||
                           pe && dateFns.dateFns.isFriday(paiva) ||
                           la && dateFns.dateFns.isSaturday(paiva) ||
                           su && dateFns.dateFns.isSunday(paiva);
                };

                let aloitusPaivat = dateFns.dateFns.eachDayOfInterval({ start: ensimmainenAloitusPaiva, end: viimeinenAloitusPaiva})
                                                   .filter(x => x >= rajat[0] && x <= rajat[1])
                                                   .filter(kelpaaViikonPerusteella)
                                                   .filter(kelpaaViikonpaivanPerusteella);

                return aloitusPaivat.map(paiva => {
                    let alku = dateFns.dateFnsTz.toDate(dateFns.dateFns.format(paiva, 'yyyy-MM-dd') + 'T' + aloitusaika, { timeZone: timezone });
                    return [alku, dateFns.dateFns.add(alku, kesto)];
                });
            }
        }
        

        

        window.loadingIndicator = new am4core.DataItem();
        window.loadingIndicator.categories.aktiiviset = "";
        window.loadingIndicator.values.count = {value: 0};

        let monitor = (ds, type) => {
            ds.events.on("error", errorHandler);
            on(ds.events, "started", () => {
                loadingIndicator.setCategory("aktiiviset", loadingIndicator.categories.aktiiviset + " " + type);
                loadingIndicator.setValue("count", loadingIndicator.values.count.value + 1);
            });
            on(ds.events, "ended", () => {
                loadingIndicator.setCategory("aktiiviset", loadingIndicator.categories.aktiiviset.replace(" " + type, ""));
                loadingIndicator.setValue("count", loadingIndicator.values.count.value - 1);
            });
        }

        let luoDatasource = (type, url, f) => {
            let ds = new am4core.DataSource();
            ds.url = url;
            monitor(ds, type);
            on(ds.events, "parseended", ev => {
                log("Parsitaan " + type);
                var ret = {};
                Object.values(ev.target.data).flat().forEach(x => f(ret, x));
                ev.target.data = ret;
                log("Parsittu " + type);
            });
            ds.load();
            return ds;
        };

        window.ratanumerotDS = luoDatasource("Ratanumerot", ratanumerotUrl, (ret, x) => {
            let kilometrit = x.ratakilometrit.flat();
            ret[x.ratanumero] = [Math.min.apply(Math, kilometrit)*1000, Math.max.apply(Math, kilometrit)*1000+1000];
        });

        window.valittuRatanumeroDS = new am4core.DataSource();

        window.rautatieliikennepaikatDS = luoDatasource("Rautatieliikennepaikat", rautatieliikennepaikatUrl, (ret, x) => {
            ret[x.tunniste] = {
                ratakmSijainnit: x.muutRatakmsijainnit.concat(x.virallinenRatakmsijainti != null ? [x.virallinenRatakmsijainti] : []),
                lyhenne:         x.lyhenne,
                nimi:            x.nimi,
                tyyppi:          x.tyyppi,
                uicKoodi:        x.uicKoodi,
                ratakmvalit:     x.ratakmvalit
            };
        });

        window.liikennepaikanOsatDS = luoDatasource("LiikennepaikanOsat", liikennepaikanOsatUrl, (ret, x) => {
            ret[x.tunniste] = {
                ratakmSijainnit: x.muutRatakmsijainnit.concat(x.virallinenRatakmsijainti != null ? [x.virallinenRatakmsijainti] : []),
                lyhenne:         x.lyhenne,
                nimi:            x.nimi,
                tyyppi:          "liikennepaikanosa",
                uicKoodi:        x.uicKoodi,
                ratakmvalit:     x.muutRatakmsijainnit.concat(x.virallinenRatakmsijainti != null ? [x.virallinenRatakmsijainti] : [])
                                                      .map(r => {
                    return {
                        ratanumero: r.ratanumero,
                        alku:       {ratakm: r.ratakm, etaisyys: r.etaisyys},
                        loppu:      {ratakm: r.ratakm, etaisyys: r.etaisyys}
                    };
                })
            };
        });

        window.raideosuudetDS = luoDatasource("Raideosuudet", raideosuudetUrl, (ret, x) => {
            ret[x.tunniste[0].tunniste] = {
                ratakmSijainnit: [],
                lyhenne:         x.tunniste[0].turvalaiteNimi,
                nimi:            x.tunniste[0].turvalaiteNimi,
                tyyppi:          x.tyyppi,
                uicKoodi:        x.uickoodi,
                ratakmvalit:     x.tunniste[0].ratakmvalit
            };
        });

        window.laituritDS = luoDatasource("Laiturit", laituritUrl, (ret, x) => {
            ret[x.tunniste[0].tunniste] = {
                ratakmSijainnit: [],
                lyhenne:         x.tunniste[0].tunnus,
                nimi:            x.tunniste[0].kuvaus,
                tyyppi:          x.tyyppi,
                uicKoodi:        x.uickoodi,
                ratakmvalit:     x.tunniste[0].laskennallisetRatakmvalit
            };
        });

        window.aikataulupaikatDS = new am4core.DataSource();
        aikataulupaikatDS.data = {};
        let apHandler = ev => {
            Object.values(ev.target.data).filter(x => x.uicKoodi)
                                         .forEach(x => {
                aikataulupaikatDS.data[x.uicKoodi] = x;
            });
            aikataulupaikatDS.dispatch("done", aikataulupaikatDS.data);
        };
        on(rautatieliikennepaikatDS.events, "done", apHandler);
        on(liikennepaikanOsatDS.events,     "done", apHandler);
        on(raideosuudetDS.events,           "done", apHandler);
        on(laituritDS.events,               "done", apHandler);




        let lataaAikataulu = (paiva, callback) => {
            let aikataulutDS = new am4core.DataSource();
            aikataulutDS.url = aikatauluAPIUrl + paiva;
            monitor(aikataulutDS, paiva);
            on(aikataulutDS.events, "done", ev => {
                log("Parsitaan aikataulut päivälle " + paiva);
                let aikataulupaikatMap = aikataulupaikatDS.data;
                let ret = ev.target.data.filter(x => !x.cancelled)
                                        .map(train => {
                    let data = {
                        trainData: {
                            departureDate: train.departureDate,
                            trainNumber:   train.trainNumber,
                            lahtenyt:      false
                        },
                        rows: train.timeTableRows.map(row => {
                            let sijainti = null;
                            let paikka = aikataulupaikatMap[row.stationUICCode];
                            if (paikka != null) {
                                let rkm = paikka.ratakmSijainnit.filter(x => x.ratanumero == valittuRatanumeroDS.data);
                                if (rkm.length > 0) {
                                    sijainti = rkm[0].ratakm*1000 + rkm[0].etaisyys;
                                }
                            } else {
                                log("Tuntematon UICKoodi! " + row.stationUICCode);
                            }

                            return {
                                scheduledTime: new Date(row.scheduledTime),
                                actualTime:    row.actualTime ? new Date(row.actualTime) : null,
                                sijainti:      sijainti,
                                paikka:        paikka ? paikka.lyhenne : null,
                                paaty:         0
                            };
                        })
                    };
                    if (data.rows.length > 0) {
                        data.rows[0].paaty = 1;
                        data.rows[data.rows.length-1].paaty = 1;
                    }
                    if (data.rows.find(x => x.actualTime)) {
                        data.trainData.lahtenyt = true;
                    }
                    return data;
                });
                log("Parsittiin " + ret.length + " aikataulua päivälle " + paiva);
                ret = ret.filter(x => x.rows.filter(y => y.sijainti != null).length > 1);
                log("Jätettiin " + ret.length + " aikataulua päivälle " + paiva);
                callback(ret);
                setTimeout(() => ev.target.dispose(), 1000);
            });
            aikataulutDS.load();
        };
        


        window.onload = () => {
			am4core.useTheme(am4themes_animated);
			//am4core.options.animationsEnabled = false;
            am4core.ready(() => {
                log("Aloitetaan grafiikan alustus");
                window.chart = am4core.create("chartdiv", am4charts.XYChart);

                chart.events.on("error", errorHandler);

                chart.dummyData = {};
                chart.language.locale = am4lang_fi_FI;
                chart.arrangeTooltips = false;

                chart.legend = new am4charts.Legend();
                chart.legend.position = "right";

                chart.scrollbarX = new am4core.Scrollbar();
                chart.scrollbarY = new am4core.Scrollbar();
                //chart.scrollbarX.thumb.minWidth = 40; // Hmm, tuntuisi rajoittavan zoomia...
                //chart.scrollbarY.thumb.minHeight = 40;

                chart.dateFormatter.dateFormat = "dd.MM.yyyy HH:mm:ss";
                
                chart.preloader.disabled = true; // tuntuisi aiheuttavan muunkin datan uudelleenlatausta?

                chart.cursor = new am4charts.XYCursor();
                chart.cursor.behavior = "panXY";
                //chart.cursor.maxTooltipDistance = 10;
                let cursorMod = x => {
                    x.stroke = am4core.color("#8F3985");
                    x.strokeWidth = 1;
                    x.strokeDasharray = "";
                };
                cursorMod(chart.cursor.lineX);
                cursorMod(chart.cursor.lineY);



                let xAxis = chart.xAxes.push(new am4charts.DateAxis());
                xAxis.strictMinMax = true;
                xAxis.snapTooltip = false;
                xAxis.keepSelection = true;
				//xAxis.cursorTooltipEnabled = false;
				xAxis.showOnInit = false;
				xAxis.baseInterval     = { timeUnit: "second" }; // automatiikka tuntuu asettavan joksikin muuksi
				xAxis.mainBaseInterval = { timeUnit: "second" };
                xAxis.min = rajat[0].getTime();
                xAxis.max = rajat[1].getTime();
                
                xAxis.renderer.labels.template.location = 0.0001; // akselin labelit mielellään aina grid-viivojen kohdalle
                xAxis.renderer.labels.template.tooltip = new am4core.Tooltip();
                xAxis.renderer.labels.template.tooltipText = "{value.formatDate(dd.MM.yyyy HH:mm:ss)}";
				
				on(chart.events, "ready", function () {
                    xAxis.zoomToDates(
                        ikkuna[0],
                        ikkuna[1],
                        false,
                        true
                    );
                });

                let yAxis = chart.yAxes.push(new am4charts.ValueAxis());
                yAxis.snapTooltip = false;
                yAxis.keepSelection = true;
                //yAxis.cursorTooltipEnabled = false;
                yAxis.extraMax = 0.1;
                yAxis.renderer.numberFormatter.numberFormat = "#";
                yAxis.renderer.labels.template.paddingRight = 40;
                add(yAxis.renderer.labels.template.adapter, "text", text => {
                    let n = parseInt(text);
                    return Math.floor(n/1000) + "+" + (n%1000);
                });

                add(yAxis.adapter, "getTooltipText", text => {
                    let n = parseInt(text);
                    return Math.floor(n/1000) + "+" + (n%1000);
                });



                window.ratanumeroChanged = val => {
                    if (val != valittuRatanumeroDS.data) {
                        log("Valittiin ratanumero: " + val);
                        yAxis.title.text = "(" + val + ")";
                        valittuRatanumeroDS.data = val;
                        yAxis.min = ratanumerotDS.data[val][0];
                        yAxis.max = ratanumerotDS.data[val][1];
                        log("Rajoitettiin y-akseli välille: " + yAxis.min + " - " + yAxis.max);

                        valittuRatanumeroDS.dispatch("done", {target: {data: valittuRatanumeroDS.data}});
                    }
				};
                window.aikataulupaikkaChanged = val => {
                    if (val != valittuAikataulupaikkaDS.data) {
                        log("Valittiin aikataulupaikkaketju: " + val);
                        yAxis.title.text = val;
                        valittuAikataulupaikkaDS.data = val;
                        //yAxis.min = ratanumerotDS.data[val][0];
                        //yAxis.max = ratanumerotDS.data[val][1];
                        //log("Rajoitettiin y-akseli välille: " + yAxis.min + " - " + yAxis.max);

                        valittuAikataulupaikkaDS.dispatch("done", {target: {data: valittuAikataulupaikkaDS.data}});
                    }
				};

				let yAkseliValintaContainer = chart.legend.createChild(am4core.Container);
                yAkseliValintaContainer.layout = "vertical";
				yAkseliValintaContainer.paddingBottom = 20;
				yAkseliValintaContainer.paddingLeft = 12;

                let ratanumeroContainer = yAkseliValintaContainer.createChild(am4core.Container);
				let radioButton1 = ratanumeroContainer.createChild(am4core.Label);
				radioButton1.html = "<input type='radio' id='ratanumeroRadio' name='yAkseliValinta' checked='checked' />";
                let ratanumeroSelect = ratanumeroContainer.createChild(am4core.Label);
				ratanumeroSelect.paddingLeft = 25;
                ratanumeroSelect.html = "<label for='ratanumeroRadio'><select id='ratanumero' onchange='window.ratanumeroChanged(this.value)'>{}</select></label>";
                on(ratanumerotDS.events, "done", ev => {
					let ratanumerot = Object.keys(ev.target.data).sort();
					ratanumeroSelect.html = ratanumeroSelect.html.replace("{}", ratanumerot.map(x => "<option " + (sijaintiParam == x ? "selected='selected'" : "") + ">" + x + "</option>").join());
					ratanumeroChanged(sijaintiParam);
                });

                let aikataulupaikkaContainer = yAkseliValintaContainer.createChild(am4core.Container);
                let radioButton2 = aikataulupaikkaContainer.createChild(am4core.Label);
                radioButton2.html = "<input type='radio' id='aikataulupaikkaRadio' name='yAkseliValinta' />";
                let aikataulupaikkaInput = aikataulupaikkaContainer.createChild(am4core.Label);
				aikataulupaikkaInput.paddingLeft = 25;
                aikataulupaikkaInput.html = "<label for='aikataulupaikkaRadio'><input type='text' id='aikataulupaikka' onchange='window.aikataulupaikkaChanged(this.value)'></label>";
                
                let paivitaTilat = ev => {
                    let toinenValittu = ev.target == radioButton2;
                    ratanumeroSelect.disabled = toinenValittu;
                    aikataulupaikkaInput.disabled = !toinenValittu;
                };
                on(chart.events, "ready", paivitaTilat);
                on(radioButton1.events, "hit", paivitaTilat);
                on(radioButton2.events, "hit", paivitaTilat);
                



                chart.zoomOutButton.dispose(); // default-nappi pois

                let buttonContainer = chart.plotContainer.createChild(am4core.Container);
                buttonContainer.shouldClone = false;
                buttonContainer.align = "right";
                buttonContainer.valign = "top";
                buttonContainer.zIndex = Number.MAX_SAFE_INTEGER;
                //buttonContainer.opacity = 0.75;
                buttonContainer.marginTop = 5;
                buttonContainer.marginRight = 5;
                buttonContainer.layout = "horizontal";


                var zoomButton; 
                var selectButton;

                let alustaMoodiNappi = (text, behavior) => {
                    let button = buttonContainer.createChild(am4core.Button);
                    button.label.text = text;
                    button.background.states.create("active").properties.fill = button.background.fill.lighten(-0.5);
                    on(button.events, "hit", ev => {
                        if (ev.target.isActive) {
                            chart.cursor.behavior = "panXY";
                            ev.target.isActive = false;
                        } else {
                            chart.cursor.behavior = behavior;
                            zoomButton.isActive = false;
                            selectButton.isActive = false;
                            ev.target.isActive = true;
                        }
                    });
                    return button;
                }

                zoomButton = alustaMoodiNappi("zoom", "zoomXY");
                on(chart.cursor.events, "zoomended", ev => {
                    chart.cursor.behavior = "panXY";
                    zoomButton.isActive = false;
                });

                selectButton = alustaMoodiNappi("select", "selectXY");
                on(chart.cursor.events, "selectended", ev => {
                    chart.cursor.behavior = "panXY";
                    ev.target.isActive = false;
                });
                on(chart.cursor.events, "selectended", ev => {
                    let x = ev.target.xRange;
                    let y = ev.target.yRange;
                    if (x && y) {
                        let fromX = xAxis.positionToDate(xAxis.toAxisPosition(x.start));
                        let toX   = xAxis.positionToDate(xAxis.toAxisPosition(x.end));
                        let fromY = yAxis.positionToValue(yAxis.toAxisPosition(y.start));
                        let toY   = yAxis.positionToValue(yAxis.toAxisPosition(y.end));
                        log(fromX + "->" + toX, fromY + "->" + toY);
                    }
                });

                let luoAikavalinSiirtoButton = (label, deltaMin, deltaMax) => {
                    let button = buttonContainer.createChild(am4core.Button);
                    button.label.text = label;
                    on(button.events, "hit", ev => {
                        let diff = xAxis.maxZoomed - xAxis.minZoomed;
                        xAxis.zoomToDates(new Date(xAxis.minZoomed + deltaMin(diff)), new Date(xAxis.maxZoomed + deltaMax(diff)));
                    });
                    return button;
                }

                luoAikavalinSiirtoButton("<", (x => -0.5  * x), (x => -0.5  * x)).marginLeft = 10;;
                luoAikavalinSiirtoButton(">", (x =>  0.5  * x), (x =>  0.5  * x));

                let nowButton = buttonContainer.createChild(am4core.Button);
                nowButton.label.text = "|";
                on(nowButton.events, "hit", ev => {
                    let diff = xAxis.maxZoomed - xAxis.minZoomed;
                    xAxis.zoomToDates(new Date(new Date().getTime() - diff), new Date(new Date().getTime() + diff));
                });

                luoAikavalinSiirtoButton("-", (x => -0.25 * x), (x =>  0.25 * x)).marginLeft = 10;
                luoAikavalinSiirtoButton("+", (x =>  0.2  * x), (x => -0.2  * x));

                

                window.loading = chart.plotContainer.createChild(am4core.Label);
                loading.dataItem = loadingIndicator;
                loading.fontSize = 10;
                add(loading.adapter, "text", (text, target) => {
                    if (!target.dataItem) {
                        return text;
                    }
                    let aktiiviset = target.dataItem.categories.aktiiviset;
                    return aktiiviset == "" ? "" : "Ladataan: " + aktiiviset.trim().split(" ").join(", ");
                });



                let nykyhetki = xAxis.axisRanges.create();
                nykyhetki.date = new Date();
                nykyhetki.grid.stroke          = "red";
                nykyhetki.grid.strokeWidth     = 2;
                nykyhetki.grid.strokeDasharray = "8,4";
                nykyhetki.bullet = new am4core.Triangle();
                nykyhetki.bullet.width            = 10;
                nykyhetki.bullet.height           = 10;
                nykyhetki.bullet.fill             = am4core.color("red");
                nykyhetki.bullet.horizontalCenter = "middle";
                nykyhetki.bullet.tooltipText      = "{date}";

                setInterval(() => nykyhetki.date = new Date(), 1000);

                

                let luoRangetJaBreakit = ev => {
                    log("Luodaan rangeja ja breakkeja");
                    Object.values(ev.target.data).flat().forEach(x => {
                        x.ratakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                     .forEach(function(r) {
                            let range                        = new am4charts.ValueAxisDataItem();
                            yAxis.axisRanges.push(range);
                            range.value                      = r.alku.ratakm*1000 + r.alku.etaisyys;
                            range.endValue                   = r.loppu.ratakm*1000 + r.loppu.etaisyys;
                            range.grid.stroke                = am4core.color("blue").lighten(0.5);
                            range.label.inside               = true;
                            range.label.fontSize             = 12;
                            if (x.uicKoodi) {
                                range.label.dx               = -30;
                            } else {
                                range.label.dx               = -9;
                                range.label.dy               = -15;
                                range.label.verticalCenter   = "bottom"
                                range.label.horizontalCenter = "middle"
                                range.label.rotation         = 270;
                            }
                            range.label.tooltip        = new am4core.Tooltip();
                            range.label.tooltipText    = x.tyyppi + ": " + x.nimi;
                            range.label.adapter.add("text", text => x.lyhenne);

                            if (range.value != range.endValue) {
                                range.grid.strokeWidth = 0;

                                let axisBreak          = new am4charts.ValueAxisBreak();
                                yAxis.axisBreaks.insert(axisBreak); // pitää insertoida aluksi, koska ylikirjottaa endLinet sun muut...

                                axisBreak.startValue            = range.value;
                                axisBreak.endValue              = range.endValue;
                                axisBreak.breakSize             = 0.05;
                                axisBreak.stroke                = range.grid.stroke;
                                axisBreak.endLine.strokeWidth   = 0;
                                axisBreak.startLine.strokeWidth = 0;
                                axisBreak.fillShape.opacity     = 0.2;

                                on(range.label.events, "over", () => {
                                    axisBreak.animate(
                                        [{ property: "breakSize", to: 1 }],
                                        100,
                                        am4core.ease.sinOut
                                    );
                                });
                                on(range.label.events, "hit", () => {
                                    axisBreak.animate(
                                        [{ property: "breakSize", to: 0.05 }],
                                        100,
                                        am4core.ease.quadOut
                                    );
                                });
                                
                            }
                        });
                    });
                    log("ranget ja breakit luotu");
                };
                
                on(rautatieliikennepaikatDS.events, "done", luoRangetJaBreakit);
                on(liikennepaikanOsatDS.events,     "done", luoRangetJaBreakit);
                on(raideosuudetDS.events,           "done", luoRangetJaBreakit);
                on(laituritDS.events,               "done", luoRangetJaBreakit);
                on(valittuRatanumeroDS.events,      "done", () => {
                    yAxis.axisRanges.clear()
                    yAxis.axisBreaks.clear()
                    rautatieliikennepaikatDS.load();
                    liikennepaikanOsatDS.load();
                    raideosuudetDS.load();
                    laituritDS.load();
                });



                let muotoileAikavali = vali => vali.split("/")
                                                   .map(d => dateFns.dateFns.format(new Date(d), "dd.MM.yyyy HH:mm:ss"))
                                                   .join(" - ");
                let muotoileEtaisyys = x => (x < 10 ? "000" : x < 100 ? "00" : x < 1000 ? "0" : "") + x;
                let muotoileKohde = kohde => kohde.laskennallisetRatakmvalit.map(x => '(' + x.ratanumero + ') ' + x.alku.ratakm  + '+' + muotoileEtaisyys(x.alku.etaisyys) + " - "
                                                                                                                + x.loppu.ratakm + "+" + muotoileEtaisyys(x.loppu.etaisyys))
                                                                            .join("\n");

                let luoEnnakkotieto = (x, xs) => rkmv => {
                    let alkuRkm = rkmv.alku.ratakm*1000+rkmv.alku.etaisyys;
                    let loppuRkm = rkmv.loppu.ratakm*1000+rkmv.loppu.etaisyys;
                    return {
                        tunniste:         x.tunniste,
                        sisainenTunniste: x.sisainenTunniste,
                        alkuX:            xs[0],
                        loppuX:           xs[1],
                        alkuY:            alkuRkm < yAxis.min ? yAxis.min : alkuRkm,
                        loppuY:           loppuRkm > yAxis.max ? yAxis.max : loppuRkm,
                        voimassa:         muotoileAikavali(x.voimassa),
                        /*ajankohdat:       x.ajankohdat.map(a =>  a.yhtajaksoinen ? muotoileAikavali(a.yhtajaksoinen)
                                                                                 : a.toistuva.ensimmainenAloitusPaiva + " - " +
                                                                                   a.toistuva.viimeinenAloitusPaiva + " " +
                                                                                   a.toistuva.aloitusViikot + " " +
                                                                                   a.toistuva.aloitusViikonpaivat.join("/") + " " +
                                                                                   a.toistuva.aloitusaika + " " +
                                                                                   a.toistuva.kesto)
                                                      .join("\n"),
                        alue:             x.tyonosat ? x.tyonosat.map(t => muotoileKohde(t.tekopaikka)).join("\n") :
                                          x.liikennevaikutusalue ? muotoileKohde(x.liikennevaikutusalue) :
                                          x.kohde ? muotoileKohde(x.kohde) : '',*/
                        ratanumero:       rkmv.ratanumero,
                        alkuratakm:       rkmv.alku.ratakm,
                        alkuetaisyys:     rkmv.alku.etaisyys,
                        loppuratakm:      rkmv.loppu.ratakm,
                        loppuetaisyys:    rkmv.loppu.etaisyys,
                        zIndex:           -1 * (loppuRkm - alkuRkm) * (xs[1].getTime() - xs[0].getTime())
                    };
                };
                
                let compareByInterval = (a,b) => {
                    return a.alkuX  < b.alkuX  ? -1 : a.alkuX  > b.alkuX  ? 1 :
                           a.loppuX < b.loppuX ? -1 : a.loppuX > b.loppuX ? 1 :
                           0;
                };

                let haeAktiivisetColumnit = (series, column, sisainenTunniste) => {
                    let uudetAktiiviset = series.columns.values.flatMap(x => {
                        if ((column == x.column && series.dummyData.objectCache[sisainenTunniste].length == 1 && !x.isActive) ||
                            (column != x.column && x.isActive)) {
                            return [x.dataItem.dataContext.sisainenTunniste];
                        } else {
                            return [];
                        }
                    });
                    return [...new Set(uudetAktiiviset)].map(y => { return {"name": y }; });
                };

                let luoAktiivinenListaus = (series, haeAktiiviset) => {
                    let legend = chart.legend.itemContainers.values.find(x => x.dataItem.name == series.name);
                    let aktiiviset           = new am4charts.Legend();
                    aktiiviset.parent        = legend.parent;
                    aktiiviset.insertAfter(legend);
                    aktiiviset.paddingBottom = 16;
                    aktiiviset.position      = "left";
                    aktiiviset.maxHeight     = 50;
                    aktiiviset.scrollable    = true;
                    aktiiviset.paddingLeft   = 16;
                    aktiiviset.markers.template.disabled             = true;
                    aktiiviset.itemContainers.template.paddingTop    = 0;
                    aktiiviset.itemContainers.template.paddingBottom = 0;

                    on(aktiiviset.events, "hit", ev => {
                        let nimi = ev.target.data[0].name;
                        series.dummyData.objectCache[nimi].forEach(x => {
                            x.isActive = !x.isActive;
                            aktiiviset.data = haeAktiiviset(series, x, nimi);
                        });
                    });
                    return aktiiviset;
                };

                let luoEnnakkotietoSeries = (nimi, vari, url) => {
                    log("Alustetaan " + nimi);
                    let series = new am4charts.ColumnSeries()
                    series.name                  = nimi;
                    series.fill                  = vari;
                    series.stroke                = vari.lighten(-0.2);
                    series.baseAxis              = yAxis; // https://github.com/amcharts/amcharts4/issues/2379
                    series.dataFields.openValueY = "alkuY";
                    series.dataFields.valueY     = "loppuY";
                    series.dataFields.openDateX  = "alkuX";
                    series.dataFields.dateX      = "loppuX";
                    series.cursorTooltipEnabled  = false;
                    series.showOnInit            = false;
                    series.simplifiedProcessing  = true;
                    series.fillOpacity           = 0.25;
                    series.strokeWidth           = 1;
                    series.hidden                = true;
                    series.columns.template.tooltipPosition       = "pointer";
					series.columns.template.tooltipText           = "{sisainenTunniste} ({tunniste})\n{alkuX} - {loppuX} \n({ratanumero}) {alkuratakm}+{alkuetaisyys} - {loppuratakm}+{loppuetaisyys}";
					series.columns.template.cloneTooltip          = false;
                    series.columns.template.togglable             = true;
                    series.columns.template.propertyFields.zIndex = "zIndex";
                    let columnLabel = series.columns.template.children.push(new am4core.Label());
                    columnLabel.fontSize = 13;
                    columnLabel.fill = series.stroke;
                    columnLabel.strokeWidth = 0;
                    columnLabel.text = "{sisainenTunniste}";

                    let luoState = stateName => {
                        let state = series.columns.template.states.create(stateName);
                        state.properties.zIndex = 999;
                        state.properties.fillOpacity = 1;
                        state.properties.stroke = vari.lighten(-0.8);
                    }
                    luoState("active");
                    luoState("hover");

                    monitor(series.dataSource, nimi);

                    series.dummyData = {}
                    on(series.dataSource.events, "parseended", ev => {
                        delete ev.target.component.dummyData.objectCache;
                    });
                    on(series.events, "validated", ev => {
                        if (!ev.target.dummyData.objectCache) {
                            ev.target.dummyData.objectCache = {};
                            log("Populoidaan " + ev.target.name + " object cache");
                            ev.target.columns.each(x => {
                                let tun = ev.target.dummyData.objectCache[x.dataItem.dataContext.sisainenTunniste];
                                if (!tun) {
                                    tun = [];
                                    ev.target.dummyData.objectCache[x.dataItem.dataContext.sisainenTunniste] = tun;
                                }
                                tun.push(x);
                            });
                            log(ev.target.name + " object cache populoitu");
                        }
                    });

                    on(series.columns.template.events, "over", ev => {
                        let cols = series.dummyData.objectCache[ev.target.dataItem.dataContext.sisainenTunniste];
                        if (!cols) {
                            log("Ei löydetty sarakkeita " + ev.target.dataItem.dataContext.sisainenTunniste);
                        } else {
                            cols.forEach(x => x.isHover = true);
                        }
                    });
                    on(series.columns.template.events, "out", ev => {
                        series.dummyData.objectCache[ev.target.dataItem.dataContext.sisainenTunniste].forEach(x => x.isHover = false);
                    });

                    on(series.columns.template.events, "hit", ev => {
                        series.dummyData.objectCache[ev.target.dataItem.dataContext.sisainenTunniste].filter(x => x.column != ev.target.column)
                                                                                                     .forEach(x => x.isActive = !x.isActive);
                    });

                    on(series.events, "shown", () => {
                        series.dataSource.url = url;
                        series.dataSource.load();
                    });
                    on(valittuRatanumeroDS.events, "done", () => {
                        if (!series.isHidden) {
                            series.dataSource.load();
                        }
                    });

                    on(chart.events, "ready", () => {
                        let aktiiviset = luoAktiivinenListaus(series, haeAktiivisetColumnit)
                        on(series.columns.template.events, "hit", ev => {
                            aktiiviset.data = haeAktiivisetColumnit(series, ev.target.column, ev.target.dataItem.dataContext.sisainenTunniste);
                        });
                    });

                    return series;
                };

                

                window.seriesEI = luoEnnakkotietoSeries("Ennakkoilmoitukset", am4core.color("orange"), eiUrl);
                on(seriesEI.dataSource.events, "parseended", ev => {
                    log("Parsitaan EI");
                    ev.target.data = ev.target.data.flatMap(ei =>
                        ei.ajankohdat.flatMap(ajankohtaAikavaleiksi)
                                     .flatMap(xs =>
                            ei.liikennevaikutusalue.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                             .map(luoEnnakkotieto(ei, xs))
                                                                             .sort(compareByInterval)));
                    log("Parsittu EI: " + ev.target.data.length);
                });

                window.seriesLO = luoEnnakkotietoSeries("LOilmoitukset", am4core.color("purple"), loUrl);
                on(seriesLO.dataSource.events, "parseended", ev => {
                    log("Parsitaan LO done");
                    ev.target.data = ev.target.data.flatMap(lo => {
                        let xs = [lo.ensimmainenAktiivisuusaika, lo.viimeinenAktiivisuusaika].map(d => new Date(d).getTime());
                        return lo.kohde.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                 .map(luoEnnakkotieto(lo, xs));
                    });
                    log("Parsittu LO: " + ev.target.data.length);
                });

                window.seriesES = luoEnnakkotietoSeries("Ennakkosuunnitelmat", am4core.color("green"), esUrl);
                on(seriesES.dataSource.events, "parseended", ev => {
                    log("Parsitaan ES done");
                    ev.target.data = ev.target.data.flatMap(es =>
                        es.tyonosat.flatMap(to =>
                            to.ajankohdat.flatMap(ajankohtaAikavaleiksi)
                                         .flatMap(xs =>
                                to.tekopaikka.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                              .map(luoEnnakkotieto(es, xs))
                                                                              .sort(compareByInterval))));
                    log("Parsittu ES: " + ev.target.data.length);
                });

                window.seriesVS = luoEnnakkotietoSeries("Vuosisuunnitelmat", am4core.color("violet"), vsUrl);
                on(seriesVS.dataSource.events, "parseended", ev => {
                    log("Parsitaan VS done");
                    ev.target.data = ev.target.data.flatMap(vs => {
                        return vs.ajankohdat.flatMap(ajankohtaAikavaleiksi)
                                            .flatMap(xs => {
                            return vs.kohde.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                     .map(luoEnnakkotieto(vs, xs));
                        });
                    });
                    log("Parsittu VS: " + ev.target.data.length);
                });
                
                chart.series.pushAll([seriesEI, seriesLO, seriesES, seriesVS]);


                window.sijainnitMap = {};

                window.aktiivisetJunatDS = new am4core.DataSource();
                aktiivisetJunatDS.data = {};

                let valitseJuna = dc => {
                    if (!aktiivisetJunatDS.data[dc.departureDate]) {
                        aktiivisetJunatDS.data[dc.departureDate] = {};
                    }
                    if (aktiivisetJunatDS.data[dc.departureDate][dc.trainNumber]) {
                        log("Valittiin pois juna", dc.departureDate, dc.trainNumber);
                        delete aktiivisetJunatDS.data[dc.departureDate][dc.trainNumber];
                    } else {
                        log("Valittiin päälle juna", dc.departureDate, dc.trainNumber);
                        aktiivisetJunatDS.data[dc.departureDate][dc.trainNumber] = true;
                    }
                    aktiivisetJunatDS.dispatchImmediately("done", {departureDate: dc.departureDate, trainNumber: dc.trainNumber });
                };

                window.junatSeries = new am4charts.XYSeries()
                junatSeries.name = "Junat";
                junatSeries.fill = "red";
                junatSeries.hidden = true;
                junatSeries.data = [];
                junatSeries.dataFields.dateX = "timestamp";
                junatSeries.dataFields.valueY = "sijainti";
                let bullet           = new am4charts.CircleBullet();
                bullet.circle.radius = 3;
                bullet.circle.stroke = am4core.color("red");
                bullet.circle.fill   = am4core.color("red").lighten(0.5);
                bullet.cloneTooltip  = false;
                bullet.tooltipText   = 'Lähtöpäivä: {departureDate}\nJunanumero: {trainNumber}';
                bullet.states.create("hover").properties.scale = 1.5;
                bullet.states.create("active").properties.scale = 1.5;
                let label         = bullet.children.push(new am4core.Label());
                label.strokeWidth = 0;
                label.fontSize    = 11;
                label.dx          = 2;
                label.dy          = 2;
                label.fill        = bullet.circle.fill;
                label.text        = "{trainNumber}";
                
                on(bullet.events, "hit", ev => valitseJuna(ev.target.dataItem.dataContext));
                on(aktiivisetJunatDS.events, "done", ev => {
                    log("Asetetaan junien aktiivisuudet");
                    junatSeries.bulletsContainer.children.each(b => {
                        let dc = b.dataItem.dataContext;
                        if (dc.departureDate == ev.departureDate && dc.trainNumber == ev.trainNumber) {
                            let isActive = ev.target.data[dc.departureDate] && ev.target.data[dc.departureDate][dc.trainNumber];
                            log("Asetetaan junan", ev.departureDate, ev.trainNumber, "aktiivisuudeksi", isActive);
                            b.isActive = isActive;
                        }
                    });
                });
                junatSeries.bullets.push(bullet);
                chart.series.push(junatSeries);

                let lataaSijainti = coord => {
                    let sijaintiDS = new am4core.DataSource();
                    sijaintiDS.url = ratakmMuunnosUrl.replace("{coord}", coord.join(","));
                    on(sijaintiDS.events, "done", ev => {
                        if (ev.target.data[0] && ev.target.data[0].ratakmsijainnit) {
                            log("Saatiin koordinaatille", coord, "ratakmsijainnit", ev.target.data[0].ratakmsijainnit);
                            sijainnitMap[coord] = ev.target.data[0].ratakmsijainnit;
                        } else {
                            log("Ei saatu ratakmsijainteja koordinaatille", coord);
                        }
                        setTimeout(() => ev.target.dispose(), 1000);
                    });
                    sijaintiDS.load();
                    return 0;
                };

                let ratakmsijainnit2sijainti = ratakmsijainnit => {
                    if (ratakmsijainnit) {
                        let ratakmsijainti = ratakmsijainnit.find(r => r.ratanumero == valittuRatanumeroDS.data);
                        if (ratakmsijainti) {
                            return ratakmsijainti.ratakm*1000+ratakmsijainti.etaisyys;
                        }
                    }
                    return undefined;
                };

                let muunnaJunasijainti = data => {
                    let pyoristettySijainti = data.location.coordinates.map(x => Number(Number(x).toFixed(3)));
                    let ratakmsijainnit = sijainnitMap[pyoristettySijainti];
                    return {
                        trainNumber:   data.trainNumber,
                        departureDate: data.departureDate,
                        timestamp:     new Date(data.timestamp),
                        sijainti:      ratakmsijainnit2sijainti(ratakmsijainnit) || lataaSijainti(pyoristettySijainti),
                        location:      pyoristettySijainti,
                        speed:         data.speed
                    };
                };

                setInterval(() => {
                    if (!junatSeries.hidden) {
                        let paivitetty = junatSeries.dataSource.data.filter(x => x.sijainti <= 0).map(x => {
                            x.sijainti = ratakmsijainnit2sijainti(sijainnitMap[x.location]) || 0;
                            if (x.sijainti > 0) {
                                log("Päivitettiin koordinaatille", x.location, "sijainti", x.sijainti);
                                return true;
                            }
                            return false;
                        });
                        if (paivitetty.find(x => x)) {
                            junatSeries.dataSource.dispatchImmediately("done", {data: junatSeries.dataSource.data});
                        }
                    }
                }, 1000);

                window.junatMap = {};

                junatSeries.dataSource.data = [];
                on(junatSeries.dataSource.events, "parseended", ev => {
                    ev.target.data = ev.target.data.map(muunnaJunasijainti);
                    ev.target.data.forEach( (data, index) => {
                        junatMap[data.departureDate + "_" + data.trainNumber] = index;
                    });
                    log("Ladattiin", ev.target.data.length, "junaa");
                })
                junatSeries.dataSource.updateCurrentData = true;
                junatSeries.dataSource.events.on("error", errorHandler);

                window.junasijainnit = new Paho.MQTT.Client("rata.digitraffic.fi", 443, "rafiikka_" + parseInt(Math.random() * 10000, 10));
                junasijainnit.onConnectionLost = errorHandler;
                junasijainnit.onMessageArrived = message => {
                    let data = muunnaJunasijainti(JSON.parse(message.payloadString));
                    let indeksi = junatMap[data.departureDate + "_" + data.trainNumber];
                    if (!indeksi) {
                        junatMap[data.departureDate + "_" + data.trainNumber] = junatSeries.dataSource.data.length;
                        junatSeries.dataSource.data.push(data);
                        junatSeries.invalidateData();
                    } else {
                        let d = junatSeries.dataSource.data[indeksi];
                        d.timestamp = data.timestamp;
                        d.sijainti = data.sijainti == 0 ? d.sijainti : data.sijainti;
                        d.speed = data.speed;
                        d.location = data.location;
                    }
                    junatSeries.dataSource.dispatchImmediately("done", {data: junatSeries.dataSource.data});
                };

                on(junatSeries.events, "shown", () => {
                    junatSeries.dataSource.url = junasijainnitUrl;
                    junasijainnit.connect({
                        useSSL:true,
                        timeout: 3,
                        onSuccess: () => {
                            junasijainnit.subscribe('train-locations/#', {
                                qos: 0
                            });
                        },
                        onFailure: errorHandler
                    });
                });
                on(junatSeries.events, "hidden", () => {
                    if (junasijainnit.isConnected()) {
                        junasijainnit.disconnect();
                    }
                });

                let useTimetables = true;
                if (useTimetables) {
                    log("Alustetaan aikatauluviivat");

                    let luoJunaSeries = () => {
                        let series = new am4charts.LineSeries();
                        series.strokeWidth                  = 1;
                        series.dataFields.valueY            = "sijainti";
                        series.cursorTooltipEnabled         = false;
                        series.tooltipPosition              = "pointer";
						series.tooltipText                  = "Lähtöpäivä: {dummyData.departureDate}\nJunanumero: {dummyData.trainNumber}";
						series.cloneTooltip                 = false;
                        series.numberFormatter.numberFormat = "#";
                        series.showOnInit                   = false;
                        series.simplifiedProcessing         = true;
                        series.hiddenInLegend               = true;
                        //series.minBulletDistance = 50;

						let bullet = new am4core.Circle();
						bullet.radius                     = 2;
                        bullet.cloneTooltip               = false;
                        bullet.tooltipText                = "{paikka}\n{dateX}";
						bullet.propertyFields.fillOpacity = "paaty";
						bullet.states.create("hover").properties.scale = 1.5;
						series.bullets.push(bullet);

                        let segment = series.segments.template;
						segment.interactionsEnabled = true;
						segment.cloneTooltip        = false;
                        //segment.togglable           = true;
						segment.states.create("hover").properties.strokeWidth  = 3;
						segment.states.create("active").properties.strokeWidth = 3;

                        return series;
                    }

                    let junienEsitysaikavali = 1000*60*60*24*3;
					chart.dummyData.ladatutAikataulut = {};
					chart.dummyData.ladatutToteumat = {};

                    let kutsuJunalle = (data, f) => Object.values(data).flatMap(Object.values).forEach(f);

                    let aikataulutToggle = new am4charts.LineSeries();
                    aikataulutToggle.name              = "Aikataulut";
                    aikataulutToggle.dataFields.dateX  = "scheduledTime";
                    aikataulutToggle.dataFields.valueY = "sijainti";
                    aikataulutToggle.stroke            = am4core.color("blue");
                    aikataulutToggle.fill              = am4core.color("blue");
                    aikataulutToggle.hidden            = true;
                    on(aikataulutToggle.events, "hidden", () => kutsuJunalle(chart.dummyData.ladatutAikataulut, x => x.hide()));
                    on(aikataulutToggle.events, "shown",  () => kutsuJunalle(chart.dummyData.ladatutAikataulut, x => x.show()));

                    let toteumatToggle = new am4charts.LineSeries();
                    toteumatToggle.name              = "Toteumat";
                    toteumatToggle.dataFields.dateX  = "actualTime";
                    toteumatToggle.dataFields.valueY = "sijainti";
                    toteumatToggle.stroke            = am4core.color("red");
                    toteumatToggle.fill              = am4core.color("red");
                    toteumatToggle.hidden            = true;
                    on(toteumatToggle.events, "hidden", () => kutsuJunalle(chart.dummyData.ladatutToteumat, x => x.hide()));
                    on(toteumatToggle.events, "shown",  () => kutsuJunalle(chart.dummyData.ladatutToteumat, x => x.show()));

                    chart.series.pushAll([aikataulutToggle, toteumatToggle]);

                    let junaOver = train => ev => {
                        let seriesT = chart.dummyData.ladatutToteumat[ev.target.dummyData.departureDate][ev.target.dummyData.trainNumber];
                        if (seriesT) {
                            log("Näytetään toteuma junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            seriesT.show();
                        } else {
                            log("Luodaan toteuma junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            luoToteuma(train).forEach(x => {
                                x.hidden = false;
                                chart.series.push(x);
                            });
                        };
                    };

                    let junaOut = ev => {
                        if (toteumatToggle.isHidden && !ev.target.isActive) {
                            log("Piilotetaan toteuma junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            let seriesT = chart.dummyData.ladatutToteumat[ev.target.dummyData.departureDate][ev.target.dummyData.trainNumber];
                            seriesT.hide();
                        }
                    }

                    let asetaJunaviivanAktiivisuus = (series, train) => ev => {
                        if (!series.isHidden && ev.departureDate == train.trainData.departureDate && ev.trainNumber == train.trainData.trainNumber) {
                            let isActive = ev.target.data[ev.departureDate] && ev.target.data[ev.departureDate][ev.trainNumber] == true;
                            log("Asetetaan junan", ev.departureDate, ev.trainNumber, "aktiivisuudeksi", isActive);
                            series.isActive = isActive;
                            series.segments.each(s => {
                                s.isActive = isActive;
                            });
                        }
                    };

                    let luoAikataulut = data => {
                        chart.series.pushAll(data.flatMap(train => {
                            if (chart.dummyData.ladatutAikataulut[train.trainData.departureDate][train.trainData.trainNumber]) {
                                return [];
                            }
                            let seriesA              = luoJunaSeries();
                            seriesA.name             = "Aikataulu";
                            seriesA.dataFields.dateX = "scheduledTime";
                            seriesA.stroke           = am4core.color("blue");
                            seriesA.fill             = am4core.color("blue");
                            seriesA.dummyData        = train.trainData;
                            seriesA.data             = train.rows;
							seriesA.hidden           = aikataulutToggle.isHidden;

                            chart.dummyData.ladatutAikataulut[train.trainData.departureDate][train.trainData.trainNumber] = seriesA;

							on(seriesA.events, "over", junaOver(train));
							on(seriesA.events, "out", junaOut);

                            on(seriesA.bullets.values[0].events, "hit", ev => valitseJuna(train.trainData));
                            on(seriesA.segments.template.events, "hit", ev => valitseJuna(train.trainData));

                            on(aktiivisetJunatDS.events, "done", asetaJunaviivanAktiivisuus(seriesA, train));

                            return [seriesA];
                        }));
					};
					let luoToteuma = train => {
                        if (chart.dummyData.ladatutToteumat[train.trainData.departureDate][train.trainData.trainNumber]) {
                            return [];
                        }
						let seriesT              = luoJunaSeries();
						seriesT.name             = "Toteuma";
						seriesT.dataFields.dateX = "actualTime";
						seriesT.stroke           = am4core.color("red");
						seriesT.fill             = am4core.color("red");
						seriesT.dummyData        = train.trainData;
                        seriesT.data             = train.rows;
						seriesT.hidden           = toteumatToggle.isHidden;

                        chart.dummyData.ladatutToteumat[train.trainData.departureDate][train.trainData.trainNumber] = seriesT;

                        on(seriesT.events, "over", junaOver(train));
                        on(seriesT.events, "out", junaOut);
                            
                        on(seriesT.bullets.values[0].events, "hit", ev => valitseJuna(train.trainData));
                        on(seriesT.segments.template.events, "hit", ev => valitseJuna(train.trainData));

                        on(aktiivisetJunatDS.events, "done", asetaJunaviivanAktiivisuus(seriesT, train));

						return [seriesT];
					};
					var luoToteumat = data => chart.series.pushAll(data.flatMap(luoToteuma));
					
                    let haeAikataulut = lahtopaiva => {
                        let paiva = dateFns.dateFns.format(lahtopaiva, 'yyyy-MM-dd');
                        if (!chart.dummyData.kokonaanLadatutAikataulut) {
                            chart.dummyData.kokonaanLadatutAikataulut = {};
                        }
                        if (!chart.dummyData.ladatutAikataulut[paiva]) {
                            chart.dummyData.ladatutAikataulut[paiva] = {};
                        }
                        if (!chart.dummyData.ladatutToteumat[paiva]) {
                            chart.dummyData.ladatutToteumat[paiva] = {};
                        }
                        if (!chart.dummyData.kokonaanLadatutAikataulut[paiva]) {
                            lataaAikataulu(paiva, luoAikataulut);
                            chart.dummyData.kokonaanLadatutAikataulut[paiva] = true;
                        }
					};
					let haeToteumat = lahtopaiva => {
                        var paiva = dateFns.dateFns.format(lahtopaiva, 'yyyy-MM-dd');
                        if (!chart.dummyData.kokonaanLadatutToteumat) {
                            chart.dummyData.kokonaanLadatutToteumat = {};
                        }
                        if (!chart.dummyData.ladatutToteumat[paiva]) {
                            chart.dummyData.ladatutToteumat[paiva] = {};
                        }
                        if (!chart.dummyData.ladatutAikataulut[paiva]) {
                            chart.dummyData.ladatutAikataulut[paiva] = {};
                        }
                        if (!chart.dummyData.kokonaanLadatutToteumat[paiva]) {
                            lataaAikataulu(paiva, luoToteumat);
                            chart.dummyData.kokonaanLadatutToteumat[paiva] = true;
                        }
                    };

                    let haeAikatauluja = () => {
                        let start = xAxis.minZoomed || ikkuna[0].getTime();
                        let end = xAxis.maxZoomed || ikkuna[1].getTime();
                        if (end-start <= junienEsitysaikavali && !aikataulutToggle.isHidden) {
                            dateFns.dateFns.eachDayOfInterval({start: new Date(start), end: new Date(end)}).forEach(haeAikataulut);
                        }
					};
					let haeToteumia = () => {
                        let start = xAxis.minZoomed || ikkuna[0].getTime();
                        let end = xAxis.maxZoomed || ikkuna[1].getTime();
                        if (end-start <= junienEsitysaikavali && !toteumatToggle.isHidden) {
                            dateFns.dateFns.eachDayOfInterval({start: new Date(start), end: new Date(end)}).forEach(haeToteumat);
                        }
                    };
                    let poistaAikataulu = series => {
                        log("Siivotaan pois juna", series.dummyData.departureDate + " " + series.dummyData.trainNumber);
						delete chart.dummyData.ladatutAikataulut[series.dummyData.departureDate][series.dummyData.trainNumber];
						delete chart.dummyData.ladatutToteumat[series.dummyData.departureDate][series.dummyData.trainNumber];
                        let index = chart.series.indexOf(series);
                        if (index >= 0) {
                            let removed = chart.series.removeIndex(index);
                            setTimeout(() => {
                                log("Viivästetysti siivotaan juna", series.dummyData.departureDate + " " + series.dummyData.trainNumber);
                                removed.dispose();
                            }, 60000);
                        }
                    };

					on(xAxis.events, "selectionextremeschanged", haeAikatauluja);
					on(xAxis.events, "selectionextremeschanged", haeToteumia);
                    on(aikataulutToggle.events, "shown", haeAikatauluja);
                    on(toteumatToggle.events,   "shown", haeToteumia);
                    on(valittuRatanumeroDS.events, "done", () => {
                        kutsuJunalle(chart.dummyData.ladatutAikataulut, poistaAikataulu);
                        kutsuJunalle(chart.dummyData.ladatutToteumat,   poistaAikataulu);
						haeAikatauluja();
						haeToteumia();
                    });

                    on(xAxis.events, "selectionextremeschanged", ev => {
                        let start = ev.target.minZoomed;
                        let end = ev.target.maxZoomed;
                        if (end-start > junienEsitysaikavali && (!aikataulutToggle.hidden || !toteumatToggle.hidden)) {
                            log("Piilotetaan junat");
                            aikataulutToggle.hide();
                            toteumatToggle.hide();
                            kutsuJunalle(chart.dummyData.ladatutAikataulut, x => x.hide());
                            kutsuJunalle(chart.dummyData.ladatutToteumat,   x => x.hide());
                        }
                    });


                    let poistaKaukaisetJunat = target => series => {
                        let disposeFurtherThanDays = 3;
                        let start = target.minZoomed;
                        let end = target.maxZoomed;
                        if (series.dummyData.departureDate < dateFns.dateFns.addDays(start, -1*disposeFurtherThanDays) ||
                            series.dummyData.departureDate > dateFns.dateFns.addDays(end,      disposeFurtherThanDays)) {
                            poistaAikataulu(series);
                        }
                    }
                    on(xAxis.events, "selectionextremeschanged", ev => {
                        kutsuJunalle(chart.dummyData.ladatutAikataulut, poistaKaukaisetJunat(ev.target));
                        kutsuJunalle(chart.dummyData.ladatutToteumat,   poistaKaukaisetJunat(ev.target));
                    });
                }

                log("Grafiikka valmis");
            });
        }
    </script>
</head>

<body>
    <h1>Rafiikka - Rataverkon reaaliaika- ja työrakografiikka</h1>
    <div id="chartdiv"></div>
</body>

</html>