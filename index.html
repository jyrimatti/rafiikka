<!DOCTYPE HTML>
<html>

<head>
    <meta charset="UTF-8">
    <style>
        #chartdiv {
            width: 100%;
            height: 500px;
        }
        h1 {
            font-weight: 100;
            font-style: italic;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            margin-left: 1em;
            margin-bottom: 0;
        }
        select {
            max-width: 7em;
        }
    </style>

    <!-- TODO
        - auttaako päällekäisten tooltippien näkymiseen jos luo joka seriesille uuden tooltip-instanssin?
        - junanumero labeliksi viivan myötäisesti
        - dateaxis custom formaatit
        - dateaxis custom gridlines
        - dateaxis päivälabel erikseen tuntitickien alle
        - yaxis custom gridlines
        - yaxis tuki aikataulupaikkaväleille
        - infinite scroll, eli kun scrollataan reunaan tai hypätään tyhjälle, niin siirretään xAxis min/max keskikohta vanhaan reunaan. Ja trigataan load ennakkotietodatalle
        - jump-to-date laatikko
        - aikataulupiste (erityisesti vaakasuora viiva) kertomaan "raide" eli siis kapasiteetinhallintayksikkö
		- sijainti heijastumaan urliin
        - ratatyöt
        - valitut objektit listaksi legendiin, tooltip mukaan
        - selectioniin valinnan alue tooltipiksi tms
        - ratanumero-akseli nyt olettaa ratakm=1000m. Miten korjata?
        - kielivalinta fi/en
        - riippuvuudet odottelemaan alkulatauksia
    -->

    <script src="https://www.amcharts.com/lib/version/4.9.19/core.js"></script>
	<script src="https://www.amcharts.com/lib/version/4.9.19/charts.js"></script>
	<script src="https://www.amcharts.com/lib/version/4.9.19/lang/fi_FI.js"></script>
    <script src="https://www.amcharts.com/lib/version/4.9.19/themes/animated.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsts/2.2.2/jsts.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/javascript.util/0.12.12/javascript.util.min.js"></script>
    <script src="datefns.js"></script>
    <script>
        let log = (msg1, msg2, msg3, msg4, msg5, msg6) => {
            if (console && console.log) {
                console.log(dateFns.dateFns.format(new Date(), 'yyyy-MM-dd HH:mm:ss.SSS'), ":", msg1, msg2, msg3, msg4, msg5, msg6);
            }
        };

        let geometryFactory = new jsts.geom.GeometryFactory();
        let geojsonReader = new jsts.io.GeoJSONReader();

        window.infraAPIUrl = 'https://rata.digitraffic.fi/infra-api/0.6/';
        window.etj2APIUrl = 'https://rata.digitraffic.fi/jeti-api/0.6/';
		window.aikatauluAPIUrl = 'https://rata.digitraffic.fi/api/v1/trains/';

		let params = new URLSearchParams(window.location.hash.replace("#", "?"));
		
        let sijaintiParam = params.get("sijainti") || "Hki-Psl-Ila-Khk-Ilr";
		let aikaParam     = new Date(params.get("aika") || new Date().toISOString());
		let kestoParam    = dateFns.durationFns.parse(params.get("kesto") || "P1D");

        log("Parametri Sijainti", sijaintiParam);
		log("Parametri Aika", aikaParam);
		log("Parametri Kesto", kestoParam);

        window.ikkuna = [dateFns.dateFns.sub(aikaParam, kestoParam), dateFns.dateFns.add(aikaParam, kestoParam)];
		window.rajat  = [dateFns.dateFns.addDays(ikkuna[0], -3), dateFns.dateFns.addDays(ikkuna[1], 3)];

        let pyoristaAjanhetki = x => dateFns.dateFns.format(x, "yyy-MM-dd'T00:00:00Z'");

		let infraAikavali = '&time=' + pyoristaAjanhetki(aikaParam) + "/" + pyoristaAjanhetki(aikaParam);
		let etj2Aikavali = '&time=' + rajat.map(function(x) { return pyoristaAjanhetki(x); }).join("/");
        let rumaAikavali = '&start=' + pyoristaAjanhetki(rajat[0]) + "&end=" + pyoristaAjanhetki(rajat[1]);

        let ratanumerotUrl            = infraAPIUrl + "radat.json?propertyName=ratakilometrit,ratanumero" + infraAikavali;
        let liikennepaikkavalitUrl    = infraAPIUrl + "liikennepaikkavalit.json?propertyName=tunniste,alkuliikennepaikka,loppuliikennepaikka" + infraAikavali;
        let reittiUrl                 = infraAPIUrl + "reitit/kaikki/{alku}/{loppu}.json?propertyName=liikennepaikat,liikennepaikanOsat,seisakkeet,linjavaihteet" + infraAikavali;

        let rautatieliikennepaikatUrl = infraAPIUrl + "rautatieliikennepaikat.json?propertyName=lyhenne,muutRatakmsijainnit,nimi,ratakmvalit,tunniste,tyyppi,uicKoodi,virallinenRatakmsijainti,virallinenSijainti&srsName=crs:84" + infraAikavali;
        let liikennepaikanOsatUrl     = infraAPIUrl + "liikennepaikanosat.json?propertyName=liikennepaikka,lyhenne,muutRatakmsijainnit,nimi,tunniste,uicKoodi,virallinenRatakmsijainti,virallinenSijainti&srsName=crs:84" + infraAikavali;
        let raideosuudetUrl           = infraAPIUrl + "aikataulupaikat.json?cql_filter=tyyppi=%27raideosuus%27&propertyName=geometria,tunniste.tunniste,tunniste.ratakmvalit,tunniste.turvalaiteNimi,tyyppi,uickoodi&srsName=crs:84" + infraAikavali;
        let laituritUrl               = infraAPIUrl + "aikataulupaikat.json?cql_filter=tyyppi=%27laituri%27&propertyName=geometria,tunniste.tunniste,tunniste.kuvaus,tunniste.laskennallisetRatakmvalit,tunniste.tunnus,tyyppi,uickoodi&srsName=crs:84" + infraAikavali;
        
        let eiUrl = etj2APIUrl + 'ennakkoilmoitukset.json?cql_filter=tila=%27hyväksytty%27&propertyName=ajankohdat,liikennevaikutusalue.laskennallisetLiikennepaikat,liikennevaikutusalue.laskennallisetLiikennepaikkavalit,liikennevaikutusalue.laskennallisetRatakmvalit,sisainenTunniste,tunniste,voimassa' + etj2Aikavali;
        let esUrl = etj2APIUrl + 'ennakkosuunnitelmat.json?cql_filter=tila=%27hyväksytty%27&propertyName=sisainenTunniste,tyonosat.ajankohdat,tyonosat.tekopaikka.laskennallisetLiikennepaikat,tyonosat.tekopaikka.laskennallisetLiikennepaikkavalit,tyonosat.tekopaikka.laskennallisetRatakmvalit,tunniste,voimassa' + etj2Aikavali;
        let vsUrl = etj2APIUrl + 'vuosisuunnitelmat.json?cql_filter=tila%3C%3E%27poistettu%27&propertyName=ajankohdat,sisainenTunniste,tunniste,kohde.laskennallisetLiikennepaikat,kohde.laskennallisetLiikennepaikkavalit,kohde.laskennallisetRatakmvalit,voimassa' + etj2Aikavali;
        let loUrl = etj2APIUrl + 'loilmoitukset.json?cql_filter=tila=%27aktiivinen%27&propertyName=ensimmainenAktiivisuusaika,ratakmvalit,sisainenTunniste,tunniste,viimeinenAktiivisuusaika' + etj2Aikavali;
        
        let junasijainnitUrl = 'https://rata.digitraffic.fi/api/v1/train-locations/latest/';
        let ratakmMuunnosUrl = 'https://rata-beta.digitraffic.fi/infra-api/0.6/koordinaatit/{coord}.json?propertyName=ratakmsijainnit&srsName=crs:84';
        
        let rtUrl = 'https://rata.digitraffic.fi/api/v1/trackwork-notifications.json?state=ACTIVE' + rumaAikavali;
        let lrUrl = 'https://rata.digitraffic.fi/api/v1/trafficrestriction-notifications.json?state=SENT' + rumaAikavali;

        let errorHandler = ev => log("Virhe!", ev);

        let loggingDelegate = f => (a, b, c) => {
            try {
                return f(a, b, c);
            } catch (e) {
                errorHandler(e);
                throw e;
            }
        };

        let on = (obj, event, f) => obj.on(event, loggingDelegate(f));

        let add = (obj, name, f) => obj.add(name, loggingDelegate(f));



        let ajankohtaAikavaleiksi = ajankohta => {
            if (ajankohta.yhtajaksoinen) {
                let ret = ajankohta.yhtajaksoinen.split("/").map(x => new Date(x));
                return ret[0] < rajat[1] && rajat[0] < ret[1]
                      ? [ret.map(function(x) { return x < rajat[0] ? rajat[0] : x > rajat[1] ? rajat[1] : x })]
                      : [];
            } else {
                let ensimmainenAloitusPaiva = new Date(ajankohta.toistuva.ensimmainenAloitusPaiva); // "2019-10-29"
                let viimeinenAloitusPaiva   = new Date(ajankohta.toistuva.viimeinenAloitusPaiva);   // "2020-05-29"
                let aloitusViikot           = ajankohta.toistuva.aloitusViikot;                     // viikottain|jokatoinen|jokaneljäs
                let aloitusViikonpaivat     = ajankohta.toistuva.aloitusViikonpaivat;               // [ma|ti|ke|to|pe|la|su]
                let timezone                = ajankohta.toistuva.timezone;                          // "Europe/Helsinki"
                let aloitusaika             = ajankohta.toistuva.aloitusaika;                       // "06:00:00"
                let kesto                   = dateFns.durationFns.parse(ajankohta.toistuva.kesto);  // "PT43200S";
                
                let kelpaaViikonPerusteella = paiva => {
                    if (aloitusViikot == 'viikottain') {
                        return true;
                    } else if (aloitusViikot == 'jokatoinen') {
                        return (dateFns.dateFns.differenceInCalendarISOWeeks(paiva, ensimmainenAloitusPaiva)) % 2 == 0;
                    } else if (aloitusViikot == 'jokaneljas') {
                        return (dateFns.dateFns.differenceInCalendarISOWeeks(paiva, ensimmainenAloitusPaiva)) % 4 == 0;
                    } else {
                        throw 'Virheellinen aloitusViikot: ' + aloitusViikot;
                    }
                };

                let ma = aloitusViikonpaivat.includes('ma');
                let ti = aloitusViikonpaivat.includes('ti');
                let ke = aloitusViikonpaivat.includes('ke');
                let to = aloitusViikonpaivat.includes('to');
                let pe = aloitusViikonpaivat.includes('pe');
                let la = aloitusViikonpaivat.includes('la');
                let su = aloitusViikonpaivat.includes('su');
                let kelpaaViikonpaivanPerusteella = paiva => {
                    return ma && dateFns.dateFns.isMonday(paiva) ||
                           ti && dateFns.dateFns.isTuesday(paiva) ||
                           ke && dateFns.dateFns.isWednesday(paiva) ||
                           to && dateFns.dateFns.isThursday(paiva) ||
                           pe && dateFns.dateFns.isFriday(paiva) ||
                           la && dateFns.dateFns.isSaturday(paiva) ||
                           su && dateFns.dateFns.isSunday(paiva);
                };

                let aloitusPaivat = dateFns.dateFns.eachDayOfInterval({ start: ensimmainenAloitusPaiva, end: viimeinenAloitusPaiva})
                                                   .filter(x => x >= rajat[0] && x <= rajat[1])
                                                   .filter(kelpaaViikonPerusteella)
                                                   .filter(kelpaaViikonpaivanPerusteella);

                return aloitusPaivat.map(paiva => {
                    let alku = dateFns.dateFnsTz.toDate(dateFns.dateFns.format(paiva, 'yyyy-MM-dd') + 'T' + aloitusaika, { timeZone: timezone });
                    return [alku, dateFns.dateFns.add(alku, kesto)];
                });
            }
        }
        

        

        window.loadingIndicator = new am4core.DataItem();
        window.loadingIndicator.categories.aktiiviset = "";
        window.loadingIndicator.values.count = {value: 0};

        let monitor = (ds, type) => {
            ds.events.on("error", errorHandler);
            on(ds.events, "started", () => {
                loadingIndicator.setCategory("aktiiviset", loadingIndicator.categories.aktiiviset + " " + type);
                loadingIndicator.setValue("count", loadingIndicator.values.count.value + 1);
            });
            on(ds.events, "ended", () => {
                loadingIndicator.setCategory("aktiiviset", loadingIndicator.categories.aktiiviset.replace(" " + type, ""));
                loadingIndicator.setValue("count", loadingIndicator.values.count.value - 1);
            });
        }

        let luoDatasource = (type, url, f) => {
            let ds = new am4core.DataSource();
            ds.url = url;
            monitor(ds, type);
            on(ds.events, "parseended", ev => {
                log("Parsitaan " + type);
                var ret = {};
                Object.values(ev.target.data).flat().forEach(x => f(ret, x));
                ev.target.data = ret;
                log("Parsittu " + type);
            });
            ds.load();
            return ds;
        };

        window.ratanumerotDS = luoDatasource("Ratanumerot", ratanumerotUrl, (ret, x) => {
            let kilometrit = x.ratakilometrit.flat();
            ret[x.ratanumero] = [Math.min.apply(Math, kilometrit)*1000, Math.max.apply(Math, kilometrit)*1000+1000];
        });

        window.liikennepaikkavalitDS = luoDatasource("Liikennepaikkavalit", liikennepaikkavalitUrl, (ret, x) => {
            ret[x.tunniste] = {
                alkuliikennepaikka:  x.alkuliikennepaikka,
                loppuliikennepaikka: x.loppuliikennepaikka
            };
        });

        window.valittuRatanumeroDS = new am4core.DataSource();
        window.valittuAikataulupaikkaDS = new am4core.DataSource();
        window.valittuRatanumeroDS.data = null;
        window.valittuAikataulupaikkaDS.data = [];

        window.rautatieliikennepaikatDS = luoDatasource("Rautatieliikennepaikat", rautatieliikennepaikatUrl, (ret, x) => {
            ret[x.tunniste] = {
                tunniste:        x.tunniste,
                ratakmSijainnit: x.muutRatakmsijainnit.concat(x.virallinenRatakmsijainti != null ? [x.virallinenRatakmsijainti] : []),
                lyhenne:         x.lyhenne,
                nimi:            x.nimi,
                tyyppi:          x.tyyppi,
                uicKoodi:        x.uicKoodi,
                geometria:       geometryFactory.buildGeometry(javascript.util.Arrays.asList([geojsonReader.read({
                                    type: "Point",
                                    coordinates: x.virallinenSijainti
                                 })])),
                ratakmvalit:     x.ratakmvalit
            };
        });

        window.liikennepaikanOsatDS = luoDatasource("LiikennepaikanOsat", liikennepaikanOsatUrl, (ret, x) => {
            ret[x.tunniste] = {
                tunniste:        x.tunniste,
                ratakmSijainnit: x.muutRatakmsijainnit.concat(x.virallinenRatakmsijainti != null ? [x.virallinenRatakmsijainti] : []),
                lyhenne:         x.lyhenne,
                liikennepaikka:  x.liikennepaikka,
                nimi:            x.nimi,
                tyyppi:          "liikennepaikanosa",
                uicKoodi:        x.uicKoodi,
                geometria:       geometryFactory.buildGeometry(javascript.util.Arrays.asList([geojsonReader.read({
                                    type: "Point",
                                    coordinates: x.virallinenSijainti
                                 })])),
                ratakmvalit:     x.muutRatakmsijainnit.concat(x.virallinenRatakmsijainti != null ? [x.virallinenRatakmsijainti] : [])
                                                      .map(r => {
                    return {
                        ratanumero: r.ratanumero,
                        alku:       {ratakm: r.ratakm, etaisyys: r.etaisyys},
                        loppu:      {ratakm: r.ratakm, etaisyys: r.etaisyys}
                    };
                })
            };
        });

        window.raideosuudetDS = luoDatasource("Raideosuudet", raideosuudetUrl, (ret, x) => {
            ret[x.tunniste[0].tunniste] = {
                tunniste:        x.tunniste,
                ratakmSijainnit: [],
                lyhenne:         x.tunniste[0].turvalaiteNimi,
                nimi:            x.tunniste[0].turvalaiteNimi,
                tyyppi:          x.tyyppi,
                uicKoodi:        x.uickoodi,
                geometria:       geometryFactory.buildGeometry(javascript.util.Arrays.asList([geojsonReader.read({
                                    type: "MultiLineString",
                                    coordinates: x.geometria
                                 })])),
                ratakmvalit:     x.tunniste[0].ratakmvalit
            };
        });

        window.laituritDS = luoDatasource("Laiturit", laituritUrl, (ret, x) => {
            ret[x.tunniste[0].tunniste] = {
                tunniste:        x.tunniste,
                ratakmSijainnit: [],
                lyhenne:         x.tunniste[0].tunnus,
                nimi:            x.tunniste[0].kuvaus,
                tyyppi:          x.tyyppi,
                uicKoodi:        x.uickoodi,
                geometria:       geometryFactory.buildGeometry(javascript.util.Arrays.asList([geojsonReader.read({
                                    type: "MultiLineString",
                                    coordinates: x.geometria
                                 })])),
                ratakmvalit:     x.tunniste[0].laskennallisetRatakmvalit
            };
        });

        window.aikataulupaikatDS = new am4core.DataSource();
        aikataulupaikatDS.data = {};
        let apHandler = ev => {
            Object.values(ev.target.data).filter(x => x.uicKoodi)
                                         .forEach(x => {
                aikataulupaikatDS.data[x.uicKoodi] = x;
                aikataulupaikatDS.data[x.tunniste] = x;
            });
            aikataulupaikatDS.dispatch("done", aikataulupaikatDS.data);
        };
        on(rautatieliikennepaikatDS.events, "done", apHandler);
        on(liikennepaikanOsatDS.events,     "done", apHandler);
        on(raideosuudetDS.events,           "done", apHandler);
        on(laituritDS.events,               "done", apHandler);




        let lataaAikataulu = (paiva, callback) => {
            let aikataulutDS = new am4core.DataSource();
            aikataulutDS.url = aikatauluAPIUrl + paiva;
            monitor(aikataulutDS, paiva);
            on(aikataulutDS.events, "done", ev => {
                log("Parsitaan aikataulut päivälle " + paiva);
                let aikataulupaikatMap = aikataulupaikatDS.data;
                let ret = ev.target.data.filter(x => !x.cancelled)
                                        .map(train => {
                    let data = {
                        trainData: {
                            departureDate: train.departureDate,
                            trainNumber:   train.trainNumber,
                            lahtenyt:      false
                        },
                        rows: train.timeTableRows.map(row => {
                            let sijainti = null;
                            let paikka = aikataulupaikatMap[row.stationUICCode];
                            if (paikka != null) {
                                let rkm = paikka.ratakmSijainnit.filter(x => x.ratanumero == valittuRatanumeroDS.data);
                                if (rkm.length > 0) {
                                    sijainti = rkm[0].ratakm*1000 + rkm[0].etaisyys;
                                } else if (valittuAikataulupaikkaDS.data.length > 0) {
                                    let sij = valittuAikataulupaikkaDS.data.indexOf(row.stationUICCode);
                                    if (sij > -1) {
                                        sijainti = sij;
                                    }
                                }
                            } else {
                                log("Tuntematon UICKoodi! " + row.stationUICCode);
                            }

                            return {
                                scheduledTime: new Date(row.scheduledTime),
                                actualTime:    row.actualTime ? new Date(row.actualTime) : null,
                                sijainti:      sijainti,
                                uicKoodi:      row.stationUICCode,
                                paikka:        paikka ? paikka.lyhenne : null,
                                paaty:         0
                            };
                        })
                    };
                    if (data.rows.length > 0) {
                        data.rows[0].paaty = 1;
                        data.rows[data.rows.length-1].paaty = 1;
                    }
                    if (data.rows.find(x => x.actualTime)) {
                        data.trainData.lahtenyt = true;
                    }
                    return data;
                });
                log("Parsittiin " + ret.length + " aikataulua päivälle " + paiva);
                if (valittuRatanumeroDS.data) {
                    ret = ret.filter(x => x.rows.filter(y => y.sijainti != null).length > 1);
                } else {
                    ret = ret.filter(x => x.rows.find(y => valittuAikataulupaikkaDS.data.includes(y.uicKoodi)));
                }
                log("Jätettiin " + ret.length + " aikataulua päivälle " + paiva);
                callback(ret);
                setTimeout(() => ev.target.dispose(), 1000);
            });
            aikataulutDS.load();
        };
        


        window.onload = () => {
			am4core.useTheme(am4themes_animated);
			//am4core.options.animationsEnabled = false;
            am4core.ready(() => {
                log("Aloitetaan grafiikan alustus");
                window.chart = am4core.create("chartdiv", am4charts.XYChart);

                chart.events.on("error", errorHandler);

                chart.dummyData = {};
                chart.language.locale = am4lang_fi_FI;
                chart.arrangeTooltips = false;

                chart.legend = new am4charts.Legend();
                chart.legend.position = "right";
                chart.legend.useDefaultMarker = true; // https://github.com/amcharts/amcharts4/issues/2444
                chart.legend.exportable = false; 

                chart.exporting.menu = new am4core.ExportMenu();
                chart.exporting.filePrefix = "rafiikka";
                chart.exporting.title = "Rafiikka";
                chart.exporting.menu.items[0].label = "⤵";

                chart.scrollbarX = new am4core.Scrollbar();
                chart.scrollbarY = new am4core.Scrollbar();
                chart.scrollbarX.exportable = false;
                chart.scrollbarY.exportable = false;

                //chart.scrollbarX.thumb.minWidth = 40; // Hmm, tuntuisi rajoittavan zoomia...
                //chart.scrollbarY.thumb.minHeight = 40;

                chart.dateFormatter.dateFormat = "dd.MM.yyyy HH:mm:ss";
                
                chart.preloader.disabled = true; // tuntuisi aiheuttavan muunkin datan uudelleenlatausta?

                chart.cursor = new am4charts.XYCursor();
                chart.cursor.behavior = "panXY";
                //chart.cursor.maxTooltipDistance = 10;
                let cursorMod = x => {
                    x.stroke = am4core.color("#8F3985");
                    x.strokeWidth = 1;
                    x.strokeDasharray = "";
                };
                cursorMod(chart.cursor.lineX);
                cursorMod(chart.cursor.lineY);



                let xAxis = chart.xAxes.push(new am4charts.DateAxis());
                xAxis.strictMinMax = true;
                xAxis.snapTooltip = false;
                xAxis.keepSelection = true;
				//xAxis.cursorTooltipEnabled = false;
				xAxis.showOnInit = false;
				xAxis.baseInterval     = { timeUnit: "second" }; // automatiikka tuntuu asettavan joksikin muuksi
				xAxis.mainBaseInterval = { timeUnit: "second" };
                xAxis.min = rajat[0].getTime();
                xAxis.max = rajat[1].getTime();
                
                xAxis.renderer.labels.template.location = 0.0001; // akselin labelit mielellään aina grid-viivojen kohdalle
                xAxis.renderer.labels.template.tooltip = new am4core.Tooltip();
                xAxis.renderer.labels.template.tooltipText = "{value.formatDate(dd.MM.yyyy HH:mm:ss)}";
				
				on(chart.events, "ready", function () {
                    xAxis.zoomToDates(
                        ikkuna[0],
                        ikkuna[1],
                        false,
                        true
                    );
                });

                let yAxis = chart.yAxes.push(new am4charts.ValueAxis());
                yAxis.snapTooltip = false;
                yAxis.keepSelection = true;
                //yAxis.cursorTooltipEnabled = false;
                yAxis.extraMax = 0.1;
                yAxis.renderer.numberFormatter.numberFormat = "#";
                add(yAxis.renderer.labels.template.adapter, "paddingRight", paddingRight => {
                    return valittuAikataulupaikkaDS.data.length > 0 ? 0 : 40;
                });

                add(yAxis.renderer.labels.template.adapter, "text", text => {
                    let n = parseInt(text);
                    return valittuAikataulupaikkaDS.data.length > 0 ? "" : Math.floor(n/1000) + "+" + (n%1000);
                });

                add(yAxis.adapter, "getTooltipText", text => {
                    let n = parseInt(text);
                    return valittuAikataulupaikkaDS.data.length > 0 ? "" : Math.floor(n/1000) + "+" + (n%1000);
                });



                window.ratanumeroChanged = val => {
                    if (!ratanumerotDS.data[val]) {
                        log("Ohitetaan, ehkä data ei ollut vielä latautunut...");
                        return false;
                    }
                    if (val != valittuRatanumeroDS.data) {
                        log("Valittiin ratanumero: " + val);
                        yAxis.title.text = "(" + val + ")";
                        valittuRatanumeroDS.data = val;
                        valittuAikataulupaikkaDS.data = [];
                        yAxis.min = ratanumerotDS.data[val][0];
                        yAxis.max = ratanumerotDS.data[val][1];
                        log("Rajoitettiin y-akseli välille: " + yAxis.min + " - " + yAxis.max);

                        valittuRatanumeroDS.dispatch("done", {target: {data: valittuRatanumeroDS.data}});
                    }
                };
                
                let ratakmsijaintiComparator = (a,b) => {
                    if (a.ratanumero < b.ratanumero) {
                        return -1;
                    } else if (a.ratanumero > b.ratanumero) {
                        return 1;
                    } else if (a.ratakm*10000+a.etaisyys < b.ratakm*10000+b.etaisyys) {
                        return -1;
                    } else if (a.ratakm*10000+a.etaisyys > b.ratakm*10000+b.etaisyys) {
                        return 1;
                    }
                    return 0;
                };
                let valissa = (ratakmsijainti,vali) => [vali[0],ratakmsijainti,vali[1]].sort(ratakmsijaintiComparator) == [vali[0],ratakmsijainti,vali[1]];

                window.aikataulupaikkaChanged = (val1, val2) => {
                    let newVal = [val1, val2].map(x => Object.values(aikataulupaikatDS.data).find(a => a.lyhenne == x.trim()));
                    if (newVal.includes(undefined)) {
                        log("Ohitetaan, ehkä data ei ollut vielä latautunut...");
                        return false;
                    }
                    newVal = newVal.map(x => x.tunniste);
                    let reittiDS = new am4core.DataSource();
                    reittiDS.url = reittiUrl.replace('{alku}', newVal[0]).replace('{loppu}', newVal[newVal.length-1]); // ignoroidaan muut kun alku ja loppu
                    monitor(reittiDS, newVal.join("-"));
                    on(reittiDS.events, "done", ev => {
                        let data = ev.target.data;
                        let lpJaOsat = data.liikennepaikat.flatMap(x => aikataulupaikatDS.data[x] ? [x] : data.liikennepaikanOsat.filter(y => liikennepaikanOsatDS.data[y].liikennepaikka == x).map(y => liikennepaikanOsatDS.data[y].tunniste));
                        let aikataulupaikat = lpJaOsat.slice(1).flatMap( (x,index) => {
                            let edellinen = lpJaOsat[index];
                            let seuraava = lpJaOsat[index+1];
                            let edelRkm = aikataulupaikatDS.data[edellinen].ratakmSijainnit;
                            let seurRkm = aikataulupaikatDS.data[seuraava].ratakmSijainnit;
                            let edelYhteiset = edelRkm.filter(y => seurRkm.map(z => z.ratanumero).includes(y.ratanumero)).sort(ratakmsijaintiComparator);
                            let seurYhteiset = seurRkm.filter(y => edelRkm.map(z => z.ratanumero).includes(y.ratanumero)).sort(ratakmsijaintiComparator);
                            let yhteisetValit = edelYhteiset.map( (y,index) => [y, seurYhteiset[index]].sort(ratakmsijaintiComparator));
                            let seisakkeet    = data.seisakkeet.filter(y => rautatieliikennepaikatDS.data[y].ratakmSijainnit.find(z => yhteisetValit.find(valissa(z))));
                            let linjavaihteet = data.linjavaihteet.filter(y => rautatieliikennepaikatDS.data[y].ratakmSijainnit.find(z => yhteisetValit.find(valissa(z))));
                            let ret = seisakkeet.concat(linjavaihteet).sort( (a,b) => ratakmsijaintiComparator(aikataulupaikatDS.data[a].ratakmSijainnit[0],aikataulupaikatDS.data[b].ratakmSijainnit[0]));
                            if (ratakmsijaintiComparator(edelRkm[0], seurRkm[0]) > 0) {
                                ret = ret.reverse();
                            }
                            return [edellinen].concat(ret).concat([seuraava]);
                        });

                        let ketju = [newVal[0]].concat(aikataulupaikat).concat([newVal[1]])
                                               .filter( (item, pos, ary) => !pos || item != ary[pos - 1])
                                               .map(x => aikataulupaikatDS.data[x].uicKoodi);
                        if (valittuAikataulupaikkaDS.data != ketju) {
                            log("Valittiin aikataulupaikkaketju: " + ketju);
                            yAxis.title.text = ketju.map(x => aikataulupaikatDS.data[x].lyhenne).join(" - ");
                            valittuRatanumeroDS.data = null;
                            valittuAikataulupaikkaDS.data = ketju;
                            yAxis.min = 0;
                            yAxis.max = valittuAikataulupaikkaDS.data.length - 1;
                            log("Rajoitettiin y-akseli välille: " + yAxis.min + " - " + yAxis.max);

                            valittuAikataulupaikkaDS.dispatch("done", {target: {data: valittuAikataulupaikkaDS.data}});
                        }
                    });
                    reittiDS.load();
                    return true;
				};

				let yAkseliValintaContainer = chart.legend.createChild(am4core.Container);
                yAkseliValintaContainer.layout = "vertical";
				yAkseliValintaContainer.paddingBottom = 20;
				yAkseliValintaContainer.paddingLeft = 12;

                let alustettu = false;
                let ratanumeroValittuna = sijaintiParam.indexOf("-") == -1;
                let ratanumeroContainer = yAkseliValintaContainer.createChild(am4core.Container);
				let radioButton1 = ratanumeroContainer.createChild(am4core.Label);
				radioButton1.html = "<input type='radio' id='ratanumeroRadio' name='yAkseliValinta' " + (ratanumeroValittuna ? "checked='checked'" : "") + " onclick='window.ratanumeroChanged(document.getElementById(\"ratanumero\").value)' />";
                let ratanumeroSelect = ratanumeroContainer.createChild(am4core.Label);
				ratanumeroSelect.paddingLeft = 25;
                ratanumeroSelect.html = "<label for='ratanumeroRadio'><select id='ratanumero' onchange='window.ratanumeroChanged(this.value)'>{}</select></label>";
                on(ratanumerotDS.events, "done", ev => {
                    if (!alustettu) {
                        let ratanumerot = Object.keys(ev.target.data).sort();
                        ratanumeroSelect.html = ratanumeroSelect.html.replace("{}", ratanumerot.map(x => "<option " + (sijaintiParam == x ? "selected='selected'" : "") + ">" + x + "</option>").join(""));
                        if (ratanumeroValittuna) {
                            if (ratanumeroChanged(sijaintiParam)) {
                                alustettu = true;
                            }
                        }
                    }
                });

                let sijaintiParams = sijaintiParam.split("-");
                if (sijaintiParams.length != 2) {
                    sijaintiParams = [undefined,undefined];
                }
                let aikataulupaikkaContainer = yAkseliValintaContainer.createChild(am4core.Container);
                let radioButton2 = aikataulupaikkaContainer.createChild(am4core.Label);
                radioButton2.html = "<input type='radio' id='aikataulupaikkaRadio' name='yAkseliValinta' " + (ratanumeroValittuna ? "" : "checked='checked'") + "onclick='window.aikataulupaikkaChanged(document.getElementById(\"aikataulupaikka1\").value,document.getElementById(\"aikataulupaikka2\").value)' />";
                let aikataulupaikkaSelect = aikataulupaikkaContainer.createChild(am4core.Label);
				aikataulupaikkaSelect.paddingLeft = 25;
                on(aikataulupaikatDS.events, "done", ev => {
                    aikataulupaikkaSelect.html = "<label for='aikataulupaikkaRadio'><select id='aikataulupaikka1' onchange='window.aikataulupaikkaChanged(this.value, document.getElementById(\"aikataulupaikka2\").value)' value='" + sijaintiParams[0] + "'>{1}</select> - " +
                                                                                   "<select id='aikataulupaikka2' onchange='window.aikataulupaikkaChanged(document.getElementById(\"aikataulupaikka1\").value, this.value)' value='" + sijaintiParams[1] + "'>{2}</select></label>";
                    let aikataulupaikat1 = Object.keys(ev.target.data).filter(x => x.indexOf(".") > -1).map(x => ev.target.data[x]).sort( (a,b) => a.lyhenne < b.lyhenne ? -1 : a.lyhenne > b.lyhenne ? 1 : 0);
                    let aikataulupaikat2 = Object.keys(ev.target.data).filter(x => x.indexOf(".") > -1).map(x => ev.target.data[x]).sort( (a,b) => a.lyhenne < b.lyhenne ? -1 : a.lyhenne > b.lyhenne ? 1 : 0);
                    let valittu1 = Object.keys(ev.target.data).filter(x => x.indexOf(".") > -1).map(x => ev.target.data[x]).find(x => x.lyhenne.toLowerCase() == sijaintiParams[0].toLowerCase());
                    if (valittu1) {
                        aikataulupaikat2.sort( (a,b) => {
                            let da = valittu1.geometria.distance(a.geometria);
                            let db = valittu1.geometria.distance(b.geometria);
                            return da < db ? -1 : da > db ? 1 : 0;
                        });
                    }
                    aikataulupaikkaSelect.html = aikataulupaikkaSelect.html.replace("{1}", aikataulupaikat1.map(x => "<option " + (sijaintiParams[0].toLowerCase() == x.lyhenne.toLowerCase() ? "selected='selected'" : "") + ">" + x.lyhenne + " (" + x.nimi + ")" + "</option>").join(""))
                                                                           .replace("{2}", aikataulupaikat2.map(x => "<option " + (sijaintiParams[1].toLowerCase() == x.lyhenne.toLowerCase() ? "selected='selected'" : "") + ">" + x.lyhenne + " (" + x.nimi + ")" + "</option>").join(""));
                    if (!alustettu) {
                        if (!ratanumeroValittuna) {
                            if (aikataulupaikkaChanged(sijaintiParams[0], sijaintiParams[1])) {
                                alustettu = true;
                            }
                        }
                    }
                });

                let paivitaTilat = ev => {
                    let toinenValittu = ev.target == radioButton2;
                    ratanumeroSelect.disabled = toinenValittu;
                    aikataulupaikkaSelect.disabled = !toinenValittu;
                };
                on(chart.events, "ready", () => {
                    let toinenValittu = !ratanumeroValittuna;
                    ratanumeroSelect.disabled = toinenValittu;
                    aikataulupaikkaSelect.disabled = !toinenValittu;
                });
                on(radioButton1.events, "hit", paivitaTilat);
                on(radioButton2.events, "hit", paivitaTilat);
                



                chart.zoomOutButton.dispose(); // default-nappi pois

                let buttonContainer = chart.plotContainer.createChild(am4core.Container);
                buttonContainer.exportable = false;
                buttonContainer.shouldClone = false;
                buttonContainer.align = "right";
                buttonContainer.valign = "top";
                buttonContainer.zIndex = Number.MAX_SAFE_INTEGER;
                //buttonContainer.opacity = 0.75;
                buttonContainer.marginTop = 5;
                buttonContainer.marginRight = 5;
                buttonContainer.layout = "horizontal";


                var zoomButton; 
                var selectButton;

                let alustaMoodiNappi = (text, behavior) => {
                    let button = buttonContainer.createChild(am4core.Button);
                    button.label.text = text;
                    button.background.states.create("active").properties.fill = button.background.fill.lighten(-0.5);
                    on(button.events, "hit", ev => {
                        if (ev.target.isActive) {
                            chart.cursor.behavior = "panXY";
                            ev.target.isActive = false;
                        } else {
                            chart.cursor.behavior = behavior;
                            zoomButton.isActive = false;
                            selectButton.isActive = false;
                            ev.target.isActive = true;
                        }
                    });
                    return button;
                }

                zoomButton = alustaMoodiNappi("zoom", "zoomXY");
                on(chart.cursor.events, "zoomended", ev => {
                    chart.cursor.behavior = "panXY";
                    zoomButton.isActive = false;
                });

                selectButton = alustaMoodiNappi("select", "selectXY");
                on(chart.cursor.events, "selectended", ev => {
                    chart.cursor.behavior = "panXY";
                    ev.target.isActive = false;
                });
                on(chart.cursor.events, "selectended", ev => {
                    let x = ev.target.xRange;
                    let y = ev.target.yRange;
                    if (x && y) {
                        let fromX = xAxis.positionToDate(xAxis.toAxisPosition(x.start));
                        let toX   = xAxis.positionToDate(xAxis.toAxisPosition(x.end));
                        let fromY = yAxis.positionToValue(yAxis.toAxisPosition(y.start));
                        let toY   = yAxis.positionToValue(yAxis.toAxisPosition(y.end));
                        log(fromX + "->" + toX, fromY + "->" + toY);
                    }
                });

                let luoAikavalinSiirtoButton = (label, deltaMin, deltaMax) => {
                    let button = buttonContainer.createChild(am4core.Button);
                    button.label.text = label;
                    on(button.events, "hit", ev => {
                        let diff = xAxis.maxZoomed - xAxis.minZoomed;
                        xAxis.zoomToDates(new Date(xAxis.minZoomed + deltaMin(diff)), new Date(xAxis.maxZoomed + deltaMax(diff)));
                    });
                    return button;
                }

                luoAikavalinSiirtoButton("<", (x => -0.5  * x), (x => -0.5  * x)).marginLeft = 10;;
                luoAikavalinSiirtoButton(">", (x =>  0.5  * x), (x =>  0.5  * x));

                let nowButton = buttonContainer.createChild(am4core.Button);
                nowButton.label.text = "|";
                on(nowButton.events, "hit", ev => {
                    let diff = xAxis.maxZoomed - xAxis.minZoomed;
                    xAxis.zoomToDates(new Date(new Date().getTime() - diff), new Date(new Date().getTime() + diff));
                });

                luoAikavalinSiirtoButton("-", (x => -0.25 * x), (x =>  0.25 * x)).marginLeft = 10;
                luoAikavalinSiirtoButton("+", (x =>  0.2  * x), (x => -0.2  * x));

                

                window.loading = chart.plotContainer.createChild(am4core.Label);
                loading.dataItem = loadingIndicator;
                loading.fontSize = 10;
                add(loading.adapter, "text", (text, target) => {
                    if (!target.dataItem) {
                        return text;
                    }
                    let aktiiviset = target.dataItem.categories.aktiiviset;
                    return aktiiviset == "" ? "" : "Ladataan: " + aktiiviset.trim().split(" ").join(", ");
                });



                let nykyhetki = xAxis.axisRanges.create();
                nykyhetki.date = new Date();
                nykyhetki.grid.stroke          = "red";
                nykyhetki.grid.strokeWidth     = 2;
                nykyhetki.grid.strokeDasharray = "8,4";
                nykyhetki.bullet = new am4core.Triangle();
                nykyhetki.bullet.width            = 10;
                nykyhetki.bullet.height           = 10;
                nykyhetki.bullet.fill             = am4core.color("red");
                nykyhetki.bullet.horizontalCenter = "middle";
                nykyhetki.bullet.tooltipText      = "{date}";

                setInterval(() => nykyhetki.date = new Date(), 1000);

                

                let luoRangetJaBreakit = ev => {
                    log("Luodaan rangeja ja breakkeja");
                    Object.values(ev.target.data).flat().forEach(x => {
                        x.ratakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                    .forEach(function(r) {
                            let range                        = new am4charts.ValueAxisDataItem();
                            yAxis.axisRanges.push(range);
                            range.value                      = r.alku.ratakm*1000 + r.alku.etaisyys;
                            range.endValue                   = r.loppu.ratakm*1000 + r.loppu.etaisyys;
                            range.grid.stroke                = am4core.color("blue").lighten(0.5);
                            range.label.inside               = true;
                            range.label.fontSize             = 12;
                            if (x.uicKoodi) {
                                range.label.dx               = -30;
                            } else {
                                range.label.dx               = -9;
                                range.label.dy               = -15;
                                range.label.verticalCenter   = "bottom"
                                range.label.horizontalCenter = "middle"
                                range.label.rotation         = 270;
                            }
                            range.label.tooltip        = new am4core.Tooltip();
                            range.label.tooltipText    = x.tyyppi + ": " + x.nimi;
                            range.label.adapter.add("text", text => x.lyhenne);

                            if (range.value != range.endValue) {
                                range.grid.strokeWidth = 0;

                                let axisBreak          = new am4charts.ValueAxisBreak();
                                yAxis.axisBreaks.insert(axisBreak); // pitää insertoida aluksi, koska ylikirjottaa endLinet sun muut...

                                axisBreak.startValue            = range.value;
                                axisBreak.endValue              = range.endValue;
                                axisBreak.breakSize             = 0.05;
                                axisBreak.stroke                = range.grid.stroke;
                                axisBreak.endLine.strokeWidth   = 0;
                                axisBreak.startLine.strokeWidth = 0;
                                axisBreak.fillShape.opacity     = 0.2;

                                on(range.label.events, "over", () => {
                                    axisBreak.animate(
                                        [{ property: "breakSize", to: 1 }],
                                        100,
                                        am4core.ease.sinOut
                                    );
                                });
                                on(range.label.events, "hit", () => {
                                    axisBreak.animate(
                                        [{ property: "breakSize", to: 0.05 }],
                                        100,
                                        am4core.ease.quadOut
                                    );
                                });
                                
                            }
                        });

                    });
                    log("ranget ja breakit luotu");
                };

                let luoRanget = () => {
                    log("Luodaan rangeja");
                    Object.values(valittuAikataulupaikkaDS.data).forEach((uicKoodi,index) => {
                        let x = aikataulupaikatDS.data[uicKoodi];
                        let range                        = new am4charts.ValueAxisDataItem();
                        yAxis.axisRanges.push(range);
                        range.value                      = index;
                        range.endValue                   = index;
                        range.grid.stroke                = am4core.color("blue").lighten(0.5);
                        range.label.dx                   = -30;
                        range.label.inside               = true;
                        range.label.fontSize             = 12;
                        range.label.tooltip        = new am4core.Tooltip();
                        range.label.tooltipText    = x.tyyppi + ": " + x.nimi;
                        range.label.adapter.add("text", text => x.lyhenne);
                    });
                };
                
                on(rautatieliikennepaikatDS.events, "done", luoRangetJaBreakit);
                on(liikennepaikanOsatDS.events,     "done", luoRangetJaBreakit);
                on(raideosuudetDS.events,           "done", luoRangetJaBreakit);
                on(laituritDS.events,               "done", luoRangetJaBreakit);
                on(valittuRatanumeroDS.events,      "done", () => {
                    yAxis.axisBreaks.clear();
                    yAxis.axisRanges.clear();
                    rautatieliikennepaikatDS.load();
                    liikennepaikanOsatDS.load();
                    raideosuudetDS.load();
                    laituritDS.load();
                });
                on(valittuAikataulupaikkaDS.events, "done", () => {
                    yAxis.axisBreaks.clear();
                    yAxis.axisRanges.clear();
                    luoRanget();
                });



                let muotoileAikavali = vali => vali.split("/")
                                                   .map(d => dateFns.dateFns.format(new Date(d), "dd.MM.yyyy HH:mm:ss"))
                                                   .join(" - ");
                let muotoileEtaisyys = x => (x < 10 ? "000" : x < 100 ? "00" : x < 1000 ? "0" : "") + x;
                let muotoileRkmv = x => '(' + x.ratanumero + ') ' + x.alku.ratakm  + '+' + muotoileEtaisyys(x.alku.etaisyys) + " - "
                                                                  + x.loppu.ratakm + "+" + muotoileEtaisyys(x.loppu.etaisyys);
                let muotoileKohde = kohde => kohde.laskennallisetRatakmvalit.map(muotoileRkmv)
                                                                            .join("\n");

                let luoEnnakkotieto = (x, xs) => rkmv => {
                    let alkuRkm = rkmv.alku.ratakm*1000+rkmv.alku.etaisyys;
                    let loppuRkm = rkmv.loppu.ratakm*1000+rkmv.loppu.etaisyys;
                    return {
                        tunniste:         x.tunniste,
                        sisainenTunniste: x.sisainenTunniste,
                        alkuX:            xs[0],
                        loppuX:           xs[1],
                        alkuY:            alkuRkm < yAxis.min ? yAxis.min : alkuRkm,
                        loppuY:           loppuRkm > yAxis.max ? yAxis.max : loppuRkm,
                        voimassa:         muotoileAikavali(x.voimassa),
                        /*ratanumero:       rkmv.ratanumero,
                        alkuratakm:       rkmv.alku.ratakm,
                        alkuetaisyys:     rkmv.alku.etaisyys,
                        loppuratakm:      rkmv.loppu.ratakm,
                        loppuetaisyys:    rkmv.loppu.etaisyys,*/
                        sijainti:         muotoileRkmv(rkmv),
                        zIndex:           -1 * (loppuRkm - alkuRkm) * (xs[1].getTime() - xs[0].getTime())
                    };
                };

                let luoEnnakkotieto2 = (x, xs) => aikataulupaikat => {
                    let lp  = x.liikennevaikutusalue ? x.liikennevaikutusalue.laskennallisetLiikennepaikat      : x.tyonosat ? x.tyonosat.flatMap(y => y.tekopaikka.laskennallisetLiikennepaikat)      : x.kohde.laskennallisetLiikennepaikat;
                    let lpv = x.liikennevaikutusalue ? x.liikennevaikutusalue.laskennallisetLiikennepaikkavalit : x.tyonosat ? x.tyonosat.flatMap(y => y.tekopaikka.laskennallisetLiikennepaikkavalit) : x.kohde.laskennallisetLiikennepaikkavalit;
                    return {
                        tunniste:         x.tunniste,
                        sisainenTunniste: x.sisainenTunniste,
                        alkuX:            xs[0],
                        loppuX:           xs[1],
                        alkuY:            aikataulupaikat[0],
                        loppuY:           aikataulupaikat[aikataulupaikat.length-1],
                        voimassa:         muotoileAikavali(x.voimassa),
                        sijainti:         lp.map(y => !rautatieliikennepaikatDS.data[y] ? '?' : rautatieliikennepaikatDS.data[y].lyhenne)
                                            .join(", ") + "\n" +
                                          lpv.map(y => !liikennepaikkavalitDS.data[y] ? '?' :
                                                       rautatieliikennepaikatDS.data[liikennepaikkavalitDS.data[y].alkuliikennepaikka].lyhenne + "-" +
                                                       rautatieliikennepaikatDS.data[liikennepaikkavalitDS.data[y].loppuliikennepaikka].lyhenne)
                                             .join(", "),
                        zIndex:           -1 * (xs[1].getTime() - xs[0].getTime())
                    };
                };
                
                let compareByInterval = (a,b) => {
                    return a.alkuX  < b.alkuX  ? -1 : a.alkuX  > b.alkuX  ? 1 :
                           a.loppuX < b.loppuX ? -1 : a.loppuX > b.loppuX ? 1 :
                           0;
                };

                let haeAktiivisetColumnit = (series, column, sisainenTunniste) => {
                    let uudetAktiiviset = series.columns.values.flatMap(x => {
                        if ((column == x.column && series.dummyData.objectCache[sisainenTunniste].length == 1 && !x.isActive) ||
                            (column != x.column && x.isActive)) {
                            return [x.dataItem.dataContext.sisainenTunniste];
                        } else {
                            return [];
                        }
                    });
                    return [...new Set(uudetAktiiviset)].map(y => { return {"name": y }; });
                };

                let luoAktiivinenListaus = series => {
                    let legend = chart.legend.itemContainers.values.find(x => x.dataItem.name == series.name);
                    let aktiiviset           = new am4charts.Legend();
                    legend.paddingBottom = 0;
                    aktiiviset.parent        = legend.parent;
                    aktiiviset.insertAfter(legend);
                    aktiiviset.paddingBottom = 16;
                    aktiiviset.fontSize      = 12;
                    aktiiviset.position      = "left";
                    aktiiviset.maxHeight     = 50;
                    aktiiviset.scrollable    = true;
                    aktiiviset.paddingLeft   = 16;
                    aktiiviset.markers.template.disabled             = true;
                    aktiiviset.itemContainers.template.paddingTop    = 0;
                    aktiiviset.itemContainers.template.paddingBottom = 0;

                    return aktiiviset;
                };

                let luoEnnakkotietoSeries = (nimi, vari, url) => {
                    log("Alustetaan " + nimi);
                    let series = new am4charts.ColumnSeries()
                    series.name                  = nimi;
                    series.fill                  = vari;
                    series.stroke                = vari.lighten(-0.2);
                    series.baseAxis              = yAxis; // https://github.com/amcharts/amcharts4/issues/2379
                    series.dataFields.openValueY = "alkuY";
                    series.dataFields.valueY     = "loppuY";
                    series.dataFields.openDateX  = "alkuX";
                    series.dataFields.dateX      = "loppuX";
                    series.cursorTooltipEnabled  = false;
                    series.showOnInit            = false;
                    series.simplifiedProcessing  = true;
                    series.fillOpacity           = 0.25;
                    series.strokeWidth           = 1;
                    series.hidden                = true;
                    series.columns.template.tooltipPosition       = "pointer";
					series.columns.template.tooltipText           = "{sisainenTunniste} ({tunniste})\n{alkuX} - {loppuX} \n{sijainti}";
					series.columns.template.cloneTooltip          = false;
                    series.columns.template.togglable             = true;
                    series.columns.template.propertyFields.zIndex = "zIndex";

                    series.hiddenState.transitionDuration = 0;
                    series.defaultState.transitionDuration = 0;

                    let columnLabel = series.columns.template.children.push(new am4core.Label());
                    columnLabel.fontSize = 13;
                    columnLabel.fill = series.stroke;
                    columnLabel.strokeWidth = 0;
                    columnLabel.text = "{sisainenTunniste}";

                    let luoState = stateName => {
                        let state = series.columns.template.states.create(stateName);
                        state.properties.zIndex = 999;
                        state.properties.fillOpacity = 1;
                        state.properties.stroke = vari.lighten(-0.8);
                    }
                    luoState("active");
                    luoState("hover");

                    monitor(series.dataSource, nimi);

                    series.dummyData = {}
                    on(series.dataSource.events, "parseended", ev => {
                        delete ev.target.component.dummyData.objectCache;
                    });
                    on(series.events, "validated", ev => {
                        if (!ev.target.dummyData.objectCache) {
                            ev.target.dummyData.objectCache = {};
                        }
                        log("Populoidaan " + ev.target.name + " object cache");
                        ev.target.columns.each(x => {
                            let tun = ev.target.dummyData.objectCache[x.dataItem.dataContext.sisainenTunniste];
                            if (!tun) {
                                tun = [];
                                ev.target.dummyData.objectCache[x.dataItem.dataContext.sisainenTunniste] = tun;
                            }
                            tun.push(x);
                        });
                        log(ev.target.name + " object cache populoitu");
                    });

                    on(series.columns.template.events, "over", ev => {
                        let cols = series.dummyData.objectCache[ev.target.dataItem.dataContext.sisainenTunniste];
                        if (!cols) {
                            log("Ei löydetty sarakkeita " + ev.target.dataItem.dataContext.sisainenTunniste);
                        } else {
                            cols.forEach(x => x.isHover = true);
                        }
                    });
                    on(series.columns.template.events, "out", ev => {
                        series.dummyData.objectCache[ev.target.dataItem.dataContext.sisainenTunniste].forEach(x => x.isHover = false);
                    });

                    on(series.columns.template.events, "hit", ev => {
                        series.dummyData.objectCache[ev.target.dataItem.dataContext.sisainenTunniste].filter(x => x.column != ev.target.column)
                                                                                                     .forEach(x => x.isActive = !x.isActive);
                    });

                    on(series.events, "shown", () => {
                        series.dataSource.url = url;
                        series.dataSource.load();
                    });
                    on(valittuRatanumeroDS.events, "done", () => {
                        if (!series.isHidden) {
                            series.dataSource.load();
                        }
                    });
                    on(valittuAikataulupaikkaDS.events, "done", () => {
                        if (!series.isHidden) {
                            series.dataSource.load();
                        }
                    });

                    on(chart.events, "ready", () => {
                        let aktiiviset = luoAktiivinenListaus(series);
                        on(aktiiviset.itemContainers.template.events, "hit", ev => {
                            let nimi = ev.target.dataItem.dataContext.name;
                            series.dummyData.objectCache[nimi].forEach(x => {
                                x.isActive = !x.isActive;
                                aktiiviset.data = haeAktiivisetColumnit(series, x, nimi);
                            });
                            aktiiviset.data = haeAktiivisetColumnit(series, series.dummyData.objectCache[nimi][0], nimi);
                        });
                        on(series.columns.template.events, "hit", ev => {
                            aktiiviset.data = haeAktiivisetColumnit(series, ev.target.column, ev.target.dataItem.dataContext.sisainenTunniste);
                        });
                    });

                    return series;
                };

                
                let aikataulupaikkaUlottumat = (lp, lpv) => {
                    let aikataulupaikat = lp.concat(lpv).flatMap(x => aikataulupaikatDS.data[x] ? [x] : Object.values(liikennepaikanOsatDS.data).filter(y => y.liikennepaikka == x).map(y => y.tunniste));
                    // TODO: seisakkeet ja linjavaihteet kun infra-api osaa kertoa ne liikennepaikkaväliltä.

                    // TODO: tarkempi laskenta jotenkin
                    return valittuAikataulupaikkaDS.data.reduce( (prev,currentUIC,currentIndex) => {
                        if (aikataulupaikat.includes(aikataulupaikatDS.data[currentUIC].tunniste)) {
                            prev[prev.length-1].push(currentIndex);
                        } else {
                            prev.push([]);
                        }
                        return prev;
                    }, [[]]);
                };

                window.seriesEI = luoEnnakkotietoSeries("Ennakkoilmoitukset", am4core.color("orange"), eiUrl);
                on(seriesEI.dataSource.events, "parseended", ev => {
                    log("Parsitaan EI");
                    ev.target.data = ev.target.data.flatMap(ei =>
                        ei.ajankohdat.flatMap(ajankohtaAikavaleiksi)
                                     .flatMap(xs => {
                            if (valittuAikataulupaikkaDS.data.length == 0) {
                                return ei.liikennevaikutusalue.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                                        .map(luoEnnakkotieto(ei, xs))
                                                                                        .sort(compareByInterval);
                            } else {
                                let lpv = ei.liikennevaikutusalue.laskennallisetLiikennepaikkavalit.flatMap(x => {
                                    let vali = liikennepaikkavalitDS.data[x];
                                    if (!vali) {
                                        log("Tuntematon liikennepaikkaväli EI:n", ei.sisainenTunniste, "liikennevaikutusalueessa");
                                        return [];
                                    }
                                    return [vali.alkuliikennepaikka, vali.loppuliikennepaikka];
                                });
                                let lp = ei.liikennevaikutusalue.laskennallisetLiikennepaikat;
                                
                                return aikataulupaikkaUlottumat(lp, lpv).map(luoEnnakkotieto2(ei, xs))
                                                                        .sort(compareByInterval);
                            };
                        }));
                    log("Parsittu EI: " + ev.target.data.length);
                });

                window.seriesLO = luoEnnakkotietoSeries("LOilmoitukset", am4core.color("purple"), loUrl);
                on(seriesLO.dataSource.events, "parseended", ev => {
                    log("Parsitaan LO done");
                    ev.target.data = ev.target.data.flatMap(lo => {
                        let xs = [lo.ensimmainenAktiivisuusaika, lo.viimeinenAktiivisuusaika].map(d => new Date(d).getTime());
                        // TODO: aikataulupaikka
                        return lo.kohde.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                 .map(luoEnnakkotieto(lo, xs));
                    });
                    log("Parsittu LO: " + ev.target.data.length);
                });

                window.seriesES = luoEnnakkotietoSeries("Ennakkosuunnitelmat", am4core.color("green"), esUrl);
                on(seriesES.dataSource.events, "parseended", ev => {
                    log("Parsitaan ES done");
                    ev.target.data = ev.target.data.flatMap(es =>
                        es.tyonosat.flatMap(to =>
                            to.ajankohdat.flatMap(ajankohtaAikavaleiksi)
                                         .flatMap(xs => {
                                if (valittuAikataulupaikkaDS.data.length == 0) {
                                    return to.tekopaikka.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                                  .map(luoEnnakkotieto(es, xs))
                                                                                  .sort(compareByInterval);
                                } else {
                                    let lpv = to.tekopaikka.laskennallisetLiikennepaikkavalit.flatMap(x => {
                                        let vali = liikennepaikkavalitDS.data[x];
                                        if (!vali) {
                                            log("Tuntematon liikennepaikkaväli ES:n", es.sisainenTunniste, "liikennevaikutusalueessa");
                                            return [];
                                        }
                                        return [vali.alkuliikennepaikka, vali.loppuliikennepaikka];
                                    });
                                    let lp = to.tekopaikka.laskennallisetLiikennepaikat;
                                    
                                    return aikataulupaikkaUlottumat(lp, lpv).map(luoEnnakkotieto2(es, xs))
                                                                            .sort(compareByInterval);
                                }
                            })))
                    log("Parsittu ES: " + ev.target.data.length);
                });

                window.seriesVS = luoEnnakkotietoSeries("Vuosisuunnitelmat", am4core.color("violet"), vsUrl);
                on(seriesVS.dataSource.events, "parseended", ev => {
                    log("Parsitaan VS done");
                    ev.target.data = ev.target.data.flatMap(vs => {
                        return vs.ajankohdat.flatMap(ajankohtaAikavaleiksi)
                                            .flatMap(xs => {
                            if (valittuAikataulupaikkaDS.data.length == 0) {
                                return vs.kohde.laskennallisetRatakmvalit.filter(x => x.ratanumero == valittuRatanumeroDS.data)
                                                                         .map(luoEnnakkotieto(vs, xs));
                            } else {
                                let lpv = vs.kohde.laskennallisetLiikennepaikkavalit.flatMap(x => {
                                    let vali = liikennepaikkavalitDS.data[x];
                                    if (!vali) {
                                        log("Tuntematon liikennepaikkaväli VS:n", vs.sisainenTunniste, "liikennevaikutusalueessa");
                                        return [];
                                    }
                                    return [vali.alkuliikennepaikka, vali.loppuliikennepaikka];
                                });
                                let lp = vs.kohde.laskennallisetLiikennepaikat;
                                
                                return aikataulupaikkaUlottumat(lp, lpv).map(luoEnnakkotieto2(vs, xs))
                                                                        .sort(compareByInterval);
                            }
                        });
                    });
                    log("Parsittu VS: " + ev.target.data.length);
                });
                
                chart.series.pushAll([seriesEI, seriesLO, seriesES, seriesVS]);


                window.sijainnitMap = {};

                window.aktiivisetJunatDS = new am4core.DataSource();
                aktiivisetJunatDS.data = {};

                let valitseJuna = dc => {
                    if (!aktiivisetJunatDS.data[dc.departureDate]) {
                        aktiivisetJunatDS.data[dc.departureDate] = {};
                    }
                    if (aktiivisetJunatDS.data[dc.departureDate][dc.trainNumber]) {
                        log("Valittiin pois juna", dc.departureDate, dc.trainNumber);
                        delete aktiivisetJunatDS.data[dc.departureDate][dc.trainNumber];
                    } else {
                        log("Valittiin päälle juna", dc.departureDate, dc.trainNumber);
                        aktiivisetJunatDS.data[dc.departureDate][dc.trainNumber] = true;
                    }
                    aktiivisetJunatDS.dispatchImmediately("done", {departureDate: dc.departureDate, trainNumber: dc.trainNumber });
                };

                window.junatSeries = new am4charts.XYSeries()
                junatSeries.name = "Junat";
                junatSeries.fill = "red";
                junatSeries.hidden = true;
                junatSeries.data = [];
                junatSeries.dataFields.dateX = "timestamp";
                junatSeries.dataFields.valueY = "sijainti";
                let bullet           = new am4charts.CircleBullet();
                bullet.circle.radius = 3;
                bullet.circle.stroke = am4core.color("red");
                bullet.circle.fill   = am4core.color("red").lighten(0.5);
                bullet.cloneTooltip  = false;
                bullet.tooltipText   = 'Lähtöpäivä: {departureDate}\nJunanumero: {trainNumber}';
                bullet.states.create("hover").properties.scale = 1.5;
                bullet.states.create("active").properties.scale = 1.5;
                let label         = bullet.children.push(new am4core.Label());
                label.strokeWidth = 0;
                label.fontSize    = 11;
                label.dx          = 2;
                label.dy          = 2;
                label.fill        = bullet.circle.fill;
                label.text        = "{trainNumber}";
                
                on(bullet.events, "hit", ev => valitseJuna(ev.target.dataItem.dataContext));
                on(aktiivisetJunatDS.events, "done", ev => {
                    log("Asetetaan junien aktiivisuudet");
                    junatSeries.bulletsContainer.children.each(b => {
                        let dc = b.dataItem.dataContext;
                        if (dc.departureDate == ev.departureDate && dc.trainNumber == ev.trainNumber) {
                            let isActive = ev.target.data[dc.departureDate] && ev.target.data[dc.departureDate][dc.trainNumber];
                            log("Asetetaan junan", ev.departureDate, ev.trainNumber, "aktiivisuudeksi", isActive);
                            b.isActive = isActive;
                        }
                    });
                });
                junatSeries.bullets.push(bullet);
                chart.series.push(junatSeries);

                let lataaSijainti = coord => {
                    if (valittuRatanumeroDS.data) {
                        let sijaintiDS = new am4core.DataSource();
                        sijaintiDS.url = ratakmMuunnosUrl.replace("{coord}", coord.join(","));
                        on(sijaintiDS.events, "done", ev => {
                            if (ev.target.data[0] && ev.target.data[0].ratakmsijainnit) {
                                log("Saatiin koordinaatille", coord, "ratakmsijainnit", ev.target.data[0].ratakmsijainnit);
                                sijainnitMap[coord] = ev.target.data[0].ratakmsijainnit;
                            } else {
                                log("Ei saatu ratakmsijainteja koordinaatille", coord);
                            }
                            setTimeout(() => ev.target.dispose(), 1000);
                        });
                        sijaintiDS.load();
                        return 0;
                    }
                    return undefined;
                };

                let etaisyys = (piste1, piste2) => Math.sqrt(Math.pow(piste1[0]-piste2[0], 2) + Math.pow(piste1[1]-piste2[1], 2));

                let koordinaatti2sijainti = data => {
                    if (valittuAikataulupaikkaDS.data.length > 0) {
                        let junanKoordinaatti = geometryFactory.buildGeometry(javascript.util.Arrays.asList([geojsonReader.read(data.location)]));

                        let sisaltyva = valittuAikataulupaikkaDS.data.flatMap( (x,index) => {
                            let paikka = aikataulupaikatDS.data[x];
                            if (paikka.geometria.getGeometryType() != 'Point') {
                                let mbc = new jsts.algorithm.MinimumBoundingCircle(paikka.geometria);
                                if (mbc.getCircle().contains(junanKoordinaatti)) {
                                    return [index];
                                }
                            }
                            return [];
                        });
                        if (sisaltyva.length > 0) {
                            log("Juna", data.departureDate, data.trainNumber, "oli sijainnissa", sisaltyva[0]);
                            return sisaltyva[0];
                        }

                        let alueet = valittuAikataulupaikkaDS.data.slice(1).map( (x,edellinenIndex) => {
                            let edellinenUicKoodi = valittuAikataulupaikkaDS.data[edellinenIndex];
                            let seuraavaUicKoodi = valittuAikataulupaikkaDS.data[edellinenIndex+1];
                            let geomList = javascript.util.Arrays.asList([aikataulupaikatDS.data[edellinenUicKoodi].geometria, aikataulupaikatDS.data[seuraavaUicKoodi].geometria]);
                            let mbc = new jsts.algorithm.MinimumBoundingCircle(geometryFactory.buildGeometry(geomList));
                            return [edellinenUicKoodi, seuraavaUicKoodi, mbc.getCircle()];
                        });
                        return alueet.filter(a => a[2].contains(junanKoordinaatti)).map(a => {
                            let edellinen = aikataulupaikatDS.data[a[0]];
                            let seuraava = aikataulupaikatDS.data[a[1]];
                            let suht = edellinen.geometria.distance(junanKoordinaatti) / edellinen.geometria.distance(seuraava.geometria);
                            let ret = valittuAikataulupaikkaDS.data.indexOf(edellinen.uicKoodi) + suht;
                            log("Laskettiin junalle", data.departureDate, data.trainNumber, "sijainti", ret);
                            return ret;
                        }).find(x => true);
                    }
                    return undefined;
                };

                let ratakmsijainnit2sijainti = ratakmsijainnit => {
                    if (valittuRatanumeroDS.data && ratakmsijainnit) {
                        let ratakmsijainti = ratakmsijainnit.find(r => r.ratanumero == valittuRatanumeroDS.data);
                        if (ratakmsijainti) {
                            return ratakmsijainti.ratakm*1000+ratakmsijainti.etaisyys;
                        }
                    }
                    return undefined;
                };

                let muunnaJunasijainti = data => {
                    let pyoristettySijainti = data.location.coordinates.map(x => Number(Number(x).toFixed(3)));
                    let ratakmsijainnit = sijainnitMap[pyoristettySijainti];
                    return {
                        trainNumber:   data.trainNumber,
                        departureDate: data.departureDate,
                        timestamp:     new Date(data.timestamp),
                        sijainti:      koordinaatti2sijainti(data) || ratakmsijainnit2sijainti(ratakmsijainnit) || lataaSijainti(pyoristettySijainti),
                        location:      pyoristettySijainti,
                        speed:         data.speed
                    };
                };

                setInterval(() => {
                    if (!junatSeries.hidden) {
                        let paivitetty = junatSeries.dataSource.data.filter(x => x.sijainti <= 0).map(x => {
                            x.sijainti = ratakmsijainnit2sijainti(sijainnitMap[x.location]) || 0;
                            if (x.sijainti > 0) {
                                log("Päivitettiin koordinaatille", x.location, "sijainti", x.sijainti);
                                return true;
                            }
                            return false;
                        });
                        if (paivitetty.find(x => x)) {
                            junatSeries.dataSource.dispatchImmediately("done", {data: junatSeries.dataSource.data});
                        }
                    }
                }, 1000);

                window.junatMap = {};

                junatSeries.dataSource.data = [];
                on(junatSeries.dataSource.events, "parseended", ev => {
                    ev.target.data = ev.target.data.map(muunnaJunasijainti);
                    ev.target.data.forEach( (data, index) => {
                        junatMap[data.departureDate + "_" + data.trainNumber] = index;
                    });
                    log("Ladattiin", ev.target.data.length, "junaa");
                })
                junatSeries.dataSource.updateCurrentData = true;
                junatSeries.dataSource.events.on("error", errorHandler);

                let haeAktiivisetJunat = () => {
                    return Object.keys(aktiivisetJunatDS.data).flatMap(dd => Object.keys(aktiivisetJunatDS.data[dd]).map(tn => { return {departureDate: dd, trainNumber: tn, "name": tn + " (" + dd + ")" }; }));
                };

                on(chart.events, "ready", () => {
                    let aktiiviset = luoAktiivinenListaus(junatSeries);
                    on(aktiiviset.itemContainers.template.events, "hit", ev => {
                        valitseJuna(ev.target.dataItem.dataContext);
                        aktiiviset.data = haeAktiivisetJunat();
                    });
                    on(aktiivisetJunatDS.events, "done", ev => {
                        aktiiviset.data = haeAktiivisetJunat();
                    });
                });

                window.junasijainnit = new Paho.MQTT.Client("rata.digitraffic.fi", 443, "rafiikka_" + parseInt(Math.random() * 10000, 10));
                junasijainnit.onConnectionLost = errorHandler;
                junasijainnit.onMessageArrived = message => {
                    let data = muunnaJunasijainti(JSON.parse(message.payloadString));
                    if (data.sijainti) {
                        let indeksi = junatMap[data.departureDate + "_" + data.trainNumber];
                        if (!indeksi) {
                            junatMap[data.departureDate + "_" + data.trainNumber] = junatSeries.dataSource.data.length;
                            junatSeries.dataSource.data.push(data);
                            junatSeries.invalidateData();
                        } else {
                            let d = junatSeries.dataSource.data[indeksi];
                            d.timestamp = data.timestamp;
                            d.sijainti = data.sijainti == 0 ? d.sijainti : data.sijainti;
                            d.speed = data.speed;
                            d.location = data.location;
                        }
                        junatSeries.dataSource.dispatchImmediately("done", {data: junatSeries.dataSource.data});
                    }
                };

                on(junatSeries.events, "shown", () => {
                    junatSeries.dataSource.url = junasijainnitUrl;
                    junasijainnit.connect({
                        useSSL:true,
                        timeout: 3,
                        onSuccess: () => {
                            junasijainnit.subscribe('train-locations/#', {
                                qos: 0
                            });
                        },
                        onFailure: errorHandler
                    });
                });
                on(junatSeries.events, "hidden", () => {
                    if (junasijainnit.isConnected()) {
                        junasijainnit.disconnect();
                    }
                });

                let useTimetables = true;
                if (useTimetables) {
                    log("Alustetaan aikatauluviivat");

                    let luoJunaSeries = () => {
                        let series = new am4charts.LineSeries();
                        series.strokeWidth                  = 1;
                        series.dataFields.valueY            = "sijainti";
                        series.cursorTooltipEnabled         = false;
                        series.tooltipPosition              = "pointer";
						series.tooltipText                  = "Lähtöpäivä: {dummyData.departureDate}\nJunanumero: {dummyData.trainNumber}";
						series.cloneTooltip                 = false;
                        series.numberFormatter.numberFormat = "#";
                        series.showOnInit                   = false;
                        series.simplifiedProcessing         = true;
                        series.hiddenInLegend               = true;
                        //series.minBulletDistance = 50;

						let bullet = new am4core.Circle();
						bullet.radius                     = 2;
                        bullet.cloneTooltip               = false;
                        bullet.tooltipText                = "{paikka}\n{dateX}";
						bullet.propertyFields.fillOpacity = "paaty";
						bullet.states.create("hover").properties.scale = 1.5;
						series.bullets.push(bullet);

                        let segment = series.segments.template;
						segment.interactionsEnabled = true;
						segment.cloneTooltip        = false;
                        //segment.togglable           = true;
						segment.states.create("hover").properties.strokeWidth  = 3;
                        segment.states.create("active").properties.strokeWidth = 3;

                        series.hiddenState.transitionDuration = 0;
                        series.defaultState.transitionDuration = 0;

                        return series;
                    }

                    let junienEsitysaikavali = 1000*60*60*24*3;
					chart.dummyData.ladatutAikataulut = {};
					chart.dummyData.ladatutToteumat = {};

                    let kutsuJunalle = (data, f) => Object.values(data).flatMap(Object.values).forEach(f);

                    let aikataulutToggle = new am4charts.LineSeries();
                    aikataulutToggle.name              = "Aikataulut";
                    aikataulutToggle.dataFields.dateX  = "scheduledTime";
                    aikataulutToggle.dataFields.valueY = "sijainti";
                    aikataulutToggle.stroke            = am4core.color("blue");
                    aikataulutToggle.fill              = am4core.color("blue");
                    aikataulutToggle.hidden            = true;
                    on(aikataulutToggle.events, "hidden", () => kutsuJunalle(chart.dummyData.ladatutAikataulut, x => x.hide()));
                    on(aikataulutToggle.events, "shown",  () => kutsuJunalle(chart.dummyData.ladatutAikataulut, x => x.show()));

                    let toteumatToggle = new am4charts.LineSeries();
                    toteumatToggle.name              = "Toteumat";
                    toteumatToggle.dataFields.dateX  = "actualTime";
                    toteumatToggle.dataFields.valueY = "sijainti";
                    toteumatToggle.stroke            = am4core.color("red");
                    toteumatToggle.fill              = am4core.color("red");
                    toteumatToggle.hidden            = true;
                    on(toteumatToggle.events, "hidden", () => kutsuJunalle(chart.dummyData.ladatutToteumat, x => x.hide()));
                    on(toteumatToggle.events, "shown",  () => kutsuJunalle(chart.dummyData.ladatutToteumat, x => x.show()));

                    chart.series.pushAll([aikataulutToggle, toteumatToggle]);

                    let junaOver = train => ev => {
                        let seriesA = chart.dummyData.ladatutAikataulut[ev.target.dummyData.departureDate][ev.target.dummyData.trainNumber];
                        if (seriesA) {
                            log("Näytetään aikataulu junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            seriesA.show();
                        } else {
                            log("Luodaan aikataulu junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            luoAikataulu(train).forEach(x => {
                                x.hidden = false;
                                chart.series.push(x);
                            });
                        };

                        let seriesT = chart.dummyData.ladatutToteumat[ev.target.dummyData.departureDate][ev.target.dummyData.trainNumber];
                        if (seriesT) {
                            log("Näytetään toteuma junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            seriesT.show();
                        } else {
                            log("Luodaan toteuma junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            luoToteuma(train).forEach(x => {
                                x.hidden = false;
                                chart.series.push(x);
                            });
                        };
                    };

                    let junaOut = ev => {
                        let aktiivinen = aktiivisetJunatDS.data[ev.target.dummyData.departureDate] && aktiivisetJunatDS.data[ev.target.dummyData.departureDate][ev.target.dummyData.trainNumber];

                        if (aikataulutToggle.isHidden && !ev.target.isActive && !aktiivinen) {
                            log("Piilotetaan aikataulu junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            let seriesA = chart.dummyData.ladatutAikataulut[ev.target.dummyData.departureDate][ev.target.dummyData.trainNumber];
                            seriesA.hide();
                        }

                        if (toteumatToggle.isHidden && !ev.target.isActive && !aktiivinen) {
                            log("Piilotetaan toteuma junalle " + ev.target.dummyData.trainNumber + " " + ev.target.dummyData.departureDate);
                            let seriesT = chart.dummyData.ladatutToteumat[ev.target.dummyData.departureDate][ev.target.dummyData.trainNumber];
                            seriesT.hide();
                        }
                    }

                    let asetaJunaviivanAktiivisuus = (series, train) => ev => {
                        if (!series.isHidden && ev.departureDate == train.trainData.departureDate && ev.trainNumber == train.trainData.trainNumber) {
                            let isActive = ev.target.data[ev.departureDate] && ev.target.data[ev.departureDate][ev.trainNumber] == true;
                            log("Asetetaan junan", ev.departureDate, ev.trainNumber, "aktiivisuudeksi", isActive);
                            series.isActive = isActive;
                            series.segments.each(s => {
                                s.isActive = isActive;
                            });
                        }
                    };

                    let luoAikataulu = train => {
                        if (chart.dummyData.ladatutAikataulut[train.trainData.departureDate][train.trainData.trainNumber]) {
                            return [];
                        }
                        let seriesA              = luoJunaSeries();
                        seriesA.name             = "Aikataulu";
                        seriesA.dataFields.dateX = "scheduledTime";
                        seriesA.stroke           = am4core.color("blue");
                        seriesA.fill             = am4core.color("blue");
                        seriesA.dummyData        = train.trainData;
                        seriesA.data             = train.rows;
                        seriesA.hidden           = aikataulutToggle.isHidden;

                        chart.dummyData.ladatutAikataulut[train.trainData.departureDate][train.trainData.trainNumber] = seriesA;

                        on(seriesA.events, "over", junaOver(train));
                        on(seriesA.events, "out", junaOut);

                        on(seriesA.bullets.values[0].events, "hit", ev => valitseJuna(train.trainData));
                        on(seriesA.segments.template.events, "hit", ev => valitseJuna(train.trainData));

                        on(aktiivisetJunatDS.events, "done", ev => {
                            asetaJunaviivanAktiivisuus(seriesA, train)(ev);

                            let aktiivinen = aktiivisetJunatDS.data[train.trainData.departureDate] && aktiivisetJunatDS.data[train.trainData.departureDate][train.trainData.trainNumber];
                            if (ev.departureDate == train.trainData.departureDate && ev.trainNumber == train.trainData.trainNumber) {
                                if (aktiivinen) {
                                    ev.target.dummyData = train.trainData;
                                    junaOver(train)(ev);
                                } else {
                                    let seriesA = chart.dummyData.ladatutAikataulut[train.trainData.departureDate][train.trainData.trainNumber];
                                    if (seriesA && !seriesA.isHidden && aikataulutToggle.hidden) {
                                        log("Piilotetaan aikataulu junalle " + train.trainData.trainNumber + " " + train.trainData.departureDate);
                                        seriesA.hide();
                                    }

                                    let seriesT = chart.dummyData.ladatutToteumat[train.trainData.departureDate][train.trainData.trainNumber];
                                    if (seriesT && !seriesT.isHidden && toteumatToggle.hidden) {
                                        log("Piilotetaan toteuma junalle " + train.trainData.trainNumber + " " + train.trainData.departureDate);
                                        seriesT.hide();
                                    }  
                                }
                            }
                        });

                        return [seriesA];
                    };
                    let luoAikataulut = data => chart.series.pushAll(data.flatMap(luoAikataulu));

					let luoToteuma = train => {
                        if (chart.dummyData.ladatutToteumat[train.trainData.departureDate][train.trainData.trainNumber]) {
                            return [];
                        }
						let seriesT              = luoJunaSeries();
						seriesT.name             = "Toteuma";
						seriesT.dataFields.dateX = "actualTime";
						seriesT.stroke           = am4core.color("red");
						seriesT.fill             = am4core.color("red");
						seriesT.dummyData        = train.trainData;
                        seriesT.data             = train.rows;
						seriesT.hidden           = toteumatToggle.isHidden;

                        chart.dummyData.ladatutToteumat[train.trainData.departureDate][train.trainData.trainNumber] = seriesT;

                        on(seriesT.events, "over", junaOver(train));
                        on(seriesT.events, "out", junaOut);
                            
                        on(seriesT.bullets.values[0].events, "hit", ev => valitseJuna(train.trainData));
                        on(seriesT.segments.template.events, "hit", ev => valitseJuna(train.trainData));

                        on(aktiivisetJunatDS.events, "done", asetaJunaviivanAktiivisuus(seriesT, train));

						return [seriesT];
					};
					var luoToteumat = data => chart.series.pushAll(data.flatMap(luoToteuma));
					
                    let haeAikataulut = lahtopaiva => {
                        let paiva = dateFns.dateFns.format(lahtopaiva, 'yyyy-MM-dd');
                        if (!chart.dummyData.kokonaanLadatutAikataulut) {
                            chart.dummyData.kokonaanLadatutAikataulut = {};
                        }
                        if (!chart.dummyData.ladatutAikataulut[paiva]) {
                            chart.dummyData.ladatutAikataulut[paiva] = {};
                        }
                        if (!chart.dummyData.ladatutToteumat[paiva]) {
                            chart.dummyData.ladatutToteumat[paiva] = {};
                        }
                        if (!chart.dummyData.kokonaanLadatutAikataulut[paiva]) {
                            lataaAikataulu(paiva, luoAikataulut);
                            chart.dummyData.kokonaanLadatutAikataulut[paiva] = true;
                        }
					};
					let haeToteumat = lahtopaiva => {
                        var paiva = dateFns.dateFns.format(lahtopaiva, 'yyyy-MM-dd');
                        if (!chart.dummyData.kokonaanLadatutToteumat) {
                            chart.dummyData.kokonaanLadatutToteumat = {};
                        }
                        if (!chart.dummyData.ladatutToteumat[paiva]) {
                            chart.dummyData.ladatutToteumat[paiva] = {};
                        }
                        if (!chart.dummyData.ladatutAikataulut[paiva]) {
                            chart.dummyData.ladatutAikataulut[paiva] = {};
                        }
                        if (!chart.dummyData.kokonaanLadatutToteumat[paiva]) {
                            lataaAikataulu(paiva, luoToteumat);
                            chart.dummyData.kokonaanLadatutToteumat[paiva] = true;
                        }
                    };

                    let haeAikatauluja = () => {
                        let start = xAxis.minZoomed || ikkuna[0].getTime();
                        let end = xAxis.maxZoomed || ikkuna[1].getTime();
                        if (end-start <= junienEsitysaikavali && !aikataulutToggle.isHidden) {
                            dateFns.dateFns.eachDayOfInterval({start: new Date(start), end: new Date(end)}).forEach(haeAikataulut);
                        }
					};
					let haeToteumia = () => {
                        let start = xAxis.minZoomed || ikkuna[0].getTime();
                        let end = xAxis.maxZoomed || ikkuna[1].getTime();
                        if (end-start <= junienEsitysaikavali && !toteumatToggle.isHidden) {
                            dateFns.dateFns.eachDayOfInterval({start: new Date(start), end: new Date(end)}).forEach(haeToteumat);
                        }
                    };
                    let poistaAikataulu = series => {
                        log("Siivotaan pois juna", series.dummyData.departureDate + " " + series.dummyData.trainNumber);
						delete chart.dummyData.ladatutAikataulut[series.dummyData.departureDate][series.dummyData.trainNumber];
						delete chart.dummyData.ladatutToteumat[series.dummyData.departureDate][series.dummyData.trainNumber];
                        let index = chart.series.indexOf(series);
                        if (index >= 0) {
                            let removed = chart.series.removeIndex(index);
                            setTimeout(() => {
                                log("Viivästetysti siivotaan juna", series.dummyData.departureDate + " " + series.dummyData.trainNumber);
                                removed.dispose();
                            }, 60000);
                        }
                    };

					on(xAxis.events, "selectionextremeschanged", haeAikatauluja);
					on(xAxis.events, "selectionextremeschanged", haeToteumia);
                    on(aikataulutToggle.events, "shown", haeAikatauluja);
                    on(toteumatToggle.events,   "shown", haeToteumia);
                    on(valittuRatanumeroDS.events, "done", () => {
                        kutsuJunalle(chart.dummyData.ladatutAikataulut, poistaAikataulu);
                        kutsuJunalle(chart.dummyData.ladatutToteumat,   poistaAikataulu);
						haeAikatauluja();
						haeToteumia();
                    });
                    on(valittuAikataulupaikkaDS.events, "done", () => {
                        kutsuJunalle(chart.dummyData.ladatutAikataulut, poistaAikataulu);
                        kutsuJunalle(chart.dummyData.ladatutToteumat,   poistaAikataulu);
						haeAikatauluja();
						haeToteumia();
                    });

                    on(xAxis.events, "selectionextremeschanged", ev => {
                        let start = ev.target.minZoomed;
                        let end = ev.target.maxZoomed;
                        if (end-start > junienEsitysaikavali && (!aikataulutToggle.hidden || !toteumatToggle.hidden)) {
                            log("Piilotetaan junat");
                            aikataulutToggle.hide();
                            toteumatToggle.hide();
                            kutsuJunalle(chart.dummyData.ladatutAikataulut, x => x.hide());
                            kutsuJunalle(chart.dummyData.ladatutToteumat,   x => x.hide());
                        }
                    });


                    let poistaKaukaisetJunat = target => series => {
                        let disposeFurtherThanDays = 3;
                        let start = target.minZoomed;
                        let end = target.maxZoomed;
                        if (series.dummyData.departureDate < dateFns.dateFns.addDays(start, -1*disposeFurtherThanDays) ||
                            series.dummyData.departureDate > dateFns.dateFns.addDays(end,      disposeFurtherThanDays)) {
                            poistaAikataulu(series);
                        }
                    }
                    on(xAxis.events, "selectionextremeschanged", ev => {
                        kutsuJunalle(chart.dummyData.ladatutAikataulut, poistaKaukaisetJunat(ev.target));
                        kutsuJunalle(chart.dummyData.ladatutToteumat,   poistaKaukaisetJunat(ev.target));
                    });
                }

                log("Grafiikka valmis");
            });
        }
    </script>
</head>

<body>
    <h1>Rafiikka - Rataverkon reaaliaika- ja työrakografiikka</h1>
    <div id="chartdiv"></div>

    <h2>Työkalu on vielä kehityksessä. Muutamia huomioita:</h2>
    <ul>
        <li>Y-akseliksi voi ratanumeron tai aikataulupaikkavälin (lyhenteillä tai UICkoodeilla)</li>
        <li>LOIlmoitusten sijoittaminen y-akselin aikataulupaikoille ei vielä toteutettu</li>
        <li>EI/ES/VS sijoittaminen y-akselin aikataulupaikoille ei toimi vielä tarkasti</li>
        <li>Junien sijoittaminen y-akselin aikataulupaikoille ei toimi vielä tarkasti</li>
        <li>Objekteja (Ennakkotiedot, junat, aikataulut, toteumat) voi valita aktiiviseksi klikkaamalla objektia</li>
        <li>Aikataulujen ja toteumien piirtäminen on hidasta kun niitä on paljon (lue: pääkaupunkiseutu)</li>
        <li>Aikataulupaikkavälin hakeminen on hidasta, koska käyttää raskasta reittihakua</li>
        <li>Y-akselin ollessa ratanumero, tehdään junasijainneille jatkuvasti gps->ratakm-muunnosta, mikä aiheuttaa paljon requesteja</li>
        <li>Aloitussijainnin voi valita urlin fragmentilla, esim: #sijainti=009</li>
        <li>Aloitusajanhetken voi valita urlin fragmentilla, esim: #aika=2020-02-14T00:00:00Z</li>
        <li>Aloitusaikavälin voi valita urlin fragmentilla, esim: #kesto=PT1H</li>
    </ul>
</body>

</html>